{
    "docs": [
        {
            "location": "/",
            "text": "Documentation\n\u00b6\n\n\n\n\nBasic Usage\n\n\nHandling Submit\n\n\nUpdating Form\n\n\nGlobal Options\n\n\nValidation Messages\n\n\nCustom Validation\n\n\nInject errors into form, aka backend validation\n\n\nUsing ngModelController\n\n\n$validators\n\n\n$asyncVaidators\n\n\n\n\n\n\n\n\n\n\nForm defaults in schema\n\n\nForm types\n\n\nDefault form types\n\n\nForm definitions\n\n\nOverriding field types and order\n\n\nStandard Options\n\n\nonChange\n\n\nValidation Messages\n\n\nInline feedback icons\n\n\nngModelOptions\n\n\ncopyValueTo\n\n\n\n\n\n\nSpecific options and types\n\n\ninput group addons\n\n\nfieldset and section\n\n\nselect and checkboxes\n\n\nactions\n\n\nbutton\n\n\nradios and radiobuttons\n\n\nhelp\n\n\ntemplate\n\n\ntabs\n\n\narray\n\n\ntabarray\n\n\n\n\n\n\nPost process function\n\n\nEvents\n\n\nManual field insertion\n\n\nDeprecated fields\n\n\nExtending Schema Form\n\n\n\n\nBasic Usage\n\u00b6\n\n\nFirst, expose your schema, form, and model to the $scope.\nDon\u2019t forget to load the \nschemaForm\n module.\n\n\nangular.module('myModule', ['schemaForm'])\n       .controller('FormController', function($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      name: { type: \"string\", minLength: 2, title: \"Name\", description: \"Name or alias\" },\n      title: {\n        type: \"string\",\n        enum: ['dr','jr','sir','mrs','mr','NaN','dj']\n      }\n    }\n  };\n\n  $scope.form = [\n    \"*\",\n    {\n      type: \"submit\",\n      title: \"Save\"\n    }\n  ];\n\n  $scope.model = {};\n}\n\n\n\n\nThen load them into Schema Form using the \nsfSchema\n, \nsfForm\n, and \nsfModel\n directives.\n\n\n<div ng-controller=\"FormController\">\n    <form sf-schema=\"schema\" sf-form=\"form\" sf-model=\"model\"></form>\n</div>\n\n\n\n\nThe \nsfSchema\n directive doesn\u2019t need to be on a form tag, in fact it can be quite useful\nto set it on a div or some such inside the form instead. Especially if you like to prefix or suffix the\nform with buttons or fields that are hard coded.\n\n\nExample with custom submit buttons:\n\n\n<div ng-controller=\"FormController\">\n  <form>\n    <p>bla bla bla</p>\n    <div sf-schema=\"schema\" sf-form=\"form\" sf-model=\"model\"></div>\n    <input type=\"submit\" value=\"Submit\">\n    <button type=\"button\" ng-click=\"goBack()\">Cancel</button>\n  </form>\n</div>\n\n\n\n\nHandling Submit\n\u00b6\n\n\nSchema Form does not care what you do with your data, to handle form submit\nthe recomended way is to use the \nng-submit\n directive. It\u2019s also recomended\nto use a \nname\n attribute on your form so you can access the\n\nFormController\n\nand check if the form is valid or not.\n\n\nYou can force a validation by broadcasting the event \nschemaFormValidate\n, ex\n\n$scope.$broadcast('schemaFormValidate')\n, this will immediately validate the\nentire form and show any errors.\n\n\nExample submit:\n\n\nfunction FormController($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      name: { type: \"string\", minLength: 2, title: \"Name\", description: \"Name or alias\" },\n      title: {\n        type: \"string\",\n        enum: ['dr','jr','sir','mrs','mr','NaN','dj']\n      }\n    }\n  };\n\n  $scope.form = [\n    \"*\",\n    {\n      type: \"submit\",\n      title: \"Save\"\n    }\n  ];\n\n  $scope.model = {};\n\n  $scope.onSubmit = function(form) {\n    // First we broadcast an event so all fields validate themselves\n    $scope.$broadcast('schemaFormValidate');\n\n    // Then we check if the form is valid\n    if (form.$valid) {\n      // ... do whatever you need to do with your data.\n    }\n  }\n}\n\n\n\n\n\nAnd the HTML would be something like this:\n\n\n<div ng-controller=\"FormController\">\n    <form name=\"myForm\"\n          sf-schema=\"schema\"\n          sf-form=\"form\"\n          sf-model=\"model\"\n          ng-submit=\"onSubmit(myForm)\"></form>\n</div>\n\n\n\n\nUpdating Form\n\u00b6\n\n\nSchema Form watches \nsf-form\n and \nsf-schema\n and will redraw the form if one or both changes, but\nonly if they change completly, i.e. not the same object and/or form instance. For performance\nreasons we have opted to not watch schema and form deeply. So if you have updated a part of the\nschema or the form definition you can trigger a redraw by issuing the event \nschemaFormRedraw\n.\n\n\nex:\n\n\nfunction Ctrl($scope) {\n  $scope.removeLastField = function() {\n    $scope.form.pop()\n    $scope.$broadcast('schemaFormRedraw')\n  }\n}\n\n\n\n\nGlobal Options\n\u00b6\n\n\nSchema Form also have two options you can set globally via the \nsf-options\n\nattribute which should be placed along side \nsf-schema\n.\n\n\nsf-options\n takes an object with the following possible attributes.\n\n\n\n\n\n\n\n\nAttribute\n\n\nType\n\n\n\n\n\n\n\n\n\n\n\n\nsupressPropertyTitles\n\n\nboolean\n\n\nby default schema form uses the property name in the schema as a title if none is specified, set this to true to disable that behavior\n\n\n\n\n\n\nformDefaults\n\n\nobject\n\n\nan object that will be used as a default for all form definitions\n\n\n\n\n\n\nvalidationMessage\n\n\nobject or function\n\n\nObject or a function that will be used as default validation message for all fields. See \nValidation Messages\n for details.\n\n\n\n\n\n\nsetSchemaDefaults\n\n\nboolean\n\n\nShould schema defaults be set on model.\n\n\n\n\n\n\ndestroyStrategy\n\n\nstring\n\n\nthe default strategy to use for cleaning the model when a form element is removed. see \ndestroyStrategy\n below\n\n\n\n\n\n\npristine\n\n\nObject \n{errors ,success}\n\n\nSets if errors and success states should be visible when form field are \n$pristine\n. Default is \n{errors: true, success: true}\n\n\n\n\n\n\nvalidateOnRender\n\n\nboolean\n\n\nShould form be validated on initial render? Default \nfalse\n\n\n\n\n\n\n\n\nformDefaults\n is mostly useful for setting global \nngModelOptions\n\ni.e. changing the entire form to validate on blur.\n\n\nEx.\n\n\n<div ng-controller=\"FormController\">\n    <form sf-schema=\"schema\"\n          sf-form=\"form\"\n          sf-model=\"model\"\n          sf-options=\"{ formDefaults: { ngModelOptions: { updateOn: 'blur' } }}\"></form>\n</div>\n\n\n\n\nValidation Messages\n\u00b6\n\n\nWe use \ntv4\n to validate the form and all of the\nvalidation messages match up \ntv4 error codes\n.\n\n\nThere are several ways to change the default validation messages.\n\n\n\n\nChange the defaults in \nsfErrorMessages\n service via its provider. This will set the validation\n     messages for all instances of \nsf-schema\n\n\nUse the global option \nvalidationMessage\n\n\nUse the form field option \nvalidationMessage\n\n\n\n\nIf a specific validation error code can\u2019t be found in the form field option, schema form looks at\nthe global option, if none is there it looks at it\u2019s own defaults and if all fails it will instead\nuse the the message under the error code \n'default'\n\n\nEx of form field option.\n\n\nvar form = [\n  \"address.zip\",\n  {\n    key: \"address.street\",\n    validationMessage: {\n      302: \"This field is like, uh, required?\"\n    }\n  }\n];\n\n\n\n\nAnd of global options\n\n\n<div ng-controller=\"FormController\">\n    <form sf-schema=\"schema\"\n          sf-form=\"form\"\n          sf-model=\"model\"\n          sf-options=\"{ validationMessage: { 302: 'Do not forget me!' }}\"></form>\n</div>\n\n\n\n\nMessage Interpolation\n\u00b6\n\n\nHaving a good validation message is hard, sometimes you need to reference the actual value, title,\nor constraint that you hit. Schema Form supports interpolation of error messages to make this a\nlittle bit easier.\n\n\nThe context variables available to you are:\n\n\n\n\n\n\n\n\nName\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nerror\n\n\nThe error code\n\n\n\n\n\n\ntitle\n\n\nTitle of the field\n\n\n\n\n\n\nvalue\n\n\nThe model value\n\n\n\n\n\n\nviewValue\n\n\nThe view value (probably the one you want)\n\n\n\n\n\n\nform\n\n\nform definition object for this field\n\n\n\n\n\n\nschema\n\n\nschema for this field\n\n\n\n\n\n\n\n\nEx.\n \njavascript\n var form = [\n   \"address.zip\",\n   {\n     key: \"address.street\",\n     validationMessage: {\n       101: 'Seriously? Value {{value}} totally less than {{schema.minimum}}, which is NOT OK.',\n     }\n   }\n ];\n\n\nTaking over: functions as validationMessages\n\u00b6\n\n\nIf you really need to control the validaton messages and interpolation is not enough (like say\nyour using \nJed\n for gettext translations) you can supply a\nfunction instead of a particular message or the entire validationMessage object.\n\n\nThe should take one argument, and that is an object with the exact same properties as the context\nused for interpolation, see table above.\n\n\nEx.\n\n\nvar form = [\n  \"address.zip\",\n  {\n    key: \"address.street\",\n    validationMessage: {\n      302: function(ctx) { return Jed.gettext('This value is required.'); },\n    }\n  }\n];\n\n\n\n\nOr:\n\n\nvar form = [\n  \"address.zip\",\n  {\n    key: \"address.street\",\n    validationMessage: function(ctx) {\n      return lookupMessage[ctx.error];\n    }\n  }\n];\n\n\n\n\nCustom Validation\n\u00b6\n\n\nSometimes the validation you want is tricky to express in a JSON Schema\nor Schema Form does not support it (yet), like \nanyOf\n and \noneOf\n.\n\n\nOther times you really need to ask the backend, maybe to check that the a username is not already\ntaken or some other constraint that only the backend can know about.\n\n\nInject errors into form aka backend validation\n\u00b6\n\n\nTo support validation outside of the form, most commonly on the backend, schema form lets you\ninjecting arbitrary validationMessages to any field and setting it\u2019s validity.\n\n\nThis is done via an event that starts with \nschemaForm.error.\n and ends with the key to the field.\nIt also takes two arguments, the first being the error code, the second being either a\nvalidation message or a boolean that sets validity, specifying a validation message automatically\nsets the field to invalid.\n\n\nSo lets do an example, say you have a form with a text field \nname\n:\n\n\nSchema\n\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": { \"type\": \"string\" }\n  }\n}\n\n\n\n\nForm\n\n\n[\n  \"name\"\n]\n\n\n\n\nTo inject an error message and set that forms validity via \nngModelController.$setValidity\n\nbroadcast an event with the name \nschemaForm.error.name\n with name/code for the error and an\noptional validation message.\n\n\nscope.$broadcast('schemaForm.error.name','usernameAlreadyTaken','The username is already taken');\n\n\n\n\nThis will invalidate the field and therefore the form and show the error message where it normally\npops up, under the field for instance.\n\n\nThere is a catch though, schema form can\u2019t know when this field is valid so you have to tell it by\nsending an event again, this time switch out the validation message for validity of the field,\ni.e. \ntrue\n.\n\n\nscope.$broadcast('schemaForm.error.name','usernameAlreadyTaken',true);\n\n\n\n\nYou can also pre-populate the validation messages if you don\u2019t want to send them in the event.\n\n\nForm\n\n\n[\n  {\n    \"key\": \"name\",\n    \"validationMessages\": {\n      \"userNameAlreadyTaken\"\n    }\n  }\n]\n\n\n\n\nscope.$broadcast('schemaForm.error.name','usernameAlreadyTaken',false);\n\n\n\n\nYou can even trigger standard tv4 error messages, just prefix the error code with \ntv4-\n\n\n// Shows the \"Required\" error message\nscope.$broadcast('schemaForm.error.name','tv4-302',false);\n\n\n\n\nUsing ngModelController\n\u00b6\n\n\nAnother way to validate your fields is to use Angulars built in support for validator functions\nand async validators via the \nngModelController\n\n\nSchema Form can expose the \nngModelController\n on a field for a function supplied with the form\ndefinition. Or you can use a shorthand by adding \n$validators\n and \n$asyncValidators\n objects as\nwell as \n$viewChangeListener\n, \n$parsers\n and \n$formatters\n arrays to your form object and they\nwill be picked up.\n\n\nNote that \n$validators\n and \n$asyncValidators\n are Angular 1.3+ only.\n\n\nSee Angular docs for details and there is also an example you can look at here\n\nexamples/custom-validators.html\n\n\n$validators\n\u00b6\n\n\nCustom validator functions are added to the \n$validators\n object and their attribute name is the\nerror code, so to specify a error message you also need to use.\n\n\n[\n  {\n    key: 'name',\n    validationMessage: {\n      'noBob': 'Bob is not OK! You here me?'\n    },\n    $validators: {\n      noBob: function(value) {\n        if (angular.isString(value) && value.indexOf('Bob') !== -1) {\n          return false;\n        }\n        return true\n      }\n    }\n  }\n]\n\n\n\n\n$asyncValidators\n\u00b6\n\n\nAsync validators are basically the same as their synchronous counterparts, but instead you return\na promise that resolves or rejects.\n\n\n[\n  {\n    key: 'name',\n    validationMessage: {\n      'noBob': 'Bob is not OK! You here me?'\n    },\n    $asyncValidators: {\n      noBob: function(value) {\n        var deferred = $q.defer();\n        $timeout(function(){\n          if (angular.isString(value) && value.indexOf('bob') !== -1) {\n            deferred.reject();\n          } else {\n            deferred.resolve();\n          }\n        }, 500);\n        return deferred.promise;\n      }\n    }\n  }\n]\n\n\n\n\nForm defaults in schema\n\u00b6\n\n\nIts recommended to split presentation and validation into a form definition and a json schema. But\nif you for some reason can\u2019t do this, but \ndo\n have the power to change the schema, you can supply form\ndefault values within the schema using the custom attribute \nx-schema-form\n. \nx-schema-form\n should\nbe a form object and acts as form definition defaults for that field.\n\n\nExample schema.\n\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"comment\": {\n      \"type\": \"string\",\n      \"title\": \"Comment\",\n      \"x-schema-form\": {\n        \"type\": \"textarea\",\n        \"placeholder\": \"Don't hold back\"\n      }\n    }\n  }\n}\n\n\n\n\nForm types\n\u00b6\n\n\nSchema Form currently supports the following form field types out of the box:\n\n\n\n\n\n\n\n\nForm Type\n\n\nBecomes\n\n\n\n\n\n\n\n\n\n\nfieldset\n\n\na fieldset with legend\n\n\n\n\n\n\nsection\n\n\njust a div\n\n\n\n\n\n\nactions\n\n\nhorizontal button list, can only submit and buttons as items\n\n\n\n\n\n\ntext\n\n\ninput with type text\n\n\n\n\n\n\ntextarea\n\n\na textarea\n\n\n\n\n\n\nnumber\n\n\ninput type number\n\n\n\n\n\n\npassword\n\n\ninput type password\n\n\n\n\n\n\ncheckbox\n\n\na checkbox\n\n\n\n\n\n\ncheckboxes\n\n\nlist of checkboxes\n\n\n\n\n\n\nselect\n\n\na select (single value)\n\n\n\n\n\n\nsubmit\n\n\na submit button\n\n\n\n\n\n\nbutton\n\n\na button\n\n\n\n\n\n\nradios\n\n\nradio buttons\n\n\n\n\n\n\nradios-inline\n\n\nradio buttons in one line\n\n\n\n\n\n\nradiobuttons\n\n\nradio buttons with bootstrap buttons\n\n\n\n\n\n\nhelp\n\n\ninsert arbitrary html\n\n\n\n\n\n\ntemplate\n\n\ninsert an angular template\n\n\n\n\n\n\ntab\n\n\ntabs with content\n\n\n\n\n\n\narray\n\n\na list you can add, remove and reorder\n\n\n\n\n\n\ntabarray\n\n\na tabbed version of array\n\n\n\n\n\n\n\n\nMore field types can be added, for instance a \u201cdatepicker\u201d type can be added by\nincluding the \ndatepicker addon\n, see\nthe \nfront page\n for an updated\nlist.\n\n\nDefault form types\n\u00b6\n\n\nSchema Form defaults to certain types of form fields depending on the schema for\na property.\n\n\n\n\n\n\n\n\nSchema\n\n\nForm type\n\n\n\n\n\n\n\n\n\n\n\u201ctype\u201d: \u201cstring\u201d\n\n\ntext\n\n\n\n\n\n\n\u201ctype\u201d: \u201cnumber\u201d\n\n\nnumber\n\n\n\n\n\n\n\u201ctype\u201d: \u201cinteger\u201d\n\n\nnumber\n\n\n\n\n\n\n\u201ctype\u201d: \u201cboolean\u201d\n\n\ncheckbox\n\n\n\n\n\n\n\u201ctype\u201d: \u201cobject\u201d\n\n\nfieldset\n\n\n\n\n\n\n\u201ctype\u201d: \u201cstring\u201d and a \u201cenum\u201d\n\n\nselect\n\n\n\n\n\n\n\u201ctype\u201d: \u201carray\u201d and a \u201cenum\u201d in array type\n\n\ncheckboxes\n\n\n\n\n\n\n\u201ctype\u201d: \u201carray\u201d\n\n\narray\n\n\n\n\n\n\n\n\nForm definitions\n\u00b6\n\n\nIf you don\u2019t supply a form definition, it will default to rendering the after the defaults taken\nfrom the schema.\n\n\nA form definition is a list where the items can be\n  * A star, \n\"*\"\n\n  * A string with the dot notated name/path to a property, \n\"name\"\n\n  * An object with that defines the options for a form field., \n{ key: \"name\" }\n\n\nThe star, \n\"*\"\n means \u201cuse the default for the entire schema\u201d and is useful when you want the\ndefaults plus an additional button.\n\n\nex.\n\n\n[\n  \"*\",\n  { type: 'submit', title: 'Save' }\n]\n\n\n\n\nThe string notation, \n\"name\"\n,  is just a shortcut for the object notation \n{ key: \"name\" }\n\nwhere key denotes what part of the schema we\u2019re creating a form field for.\n\n\nOverriding field types and order\n\u00b6\n\n\nThe order of the fields is technically undefined since the order of attributes on an javascript\nobject (which the schema ends up being) is undefined. In practice it kind of works though.\nIf you need to override the order of the forms, or just want to be sure, specify a form definition.\n\n\nex.\n\n\nvar schema = {\n  \"type\": \"object\",\n  \"properties\": {\n    \"surname\":     { \"type\": \"string\" },\n    \"firstname\":   { \"type\": \"string\" },\n  }\n}\n\n[\n  \"firstname\",\n  \"surname\"\n]\n\n\n\n\nYou can also override fields to force the type and supply other options:\nex.\n\n\nvar schema = {\n  \"type\": \"object\",\n  \"properties\": {\n    \"surname\":     { \"type\": \"string\" },\n    \"firstname\":   { \"type\": \"string\" },\n  }\n}\n\n[\n  \"firstname\",\n  {\n    key: \"surname\",\n    type: \"select\",\n    titleMap: [\n      { value: \"Andersson\", name: \"Andersson\" },\n      { value: \"Johansson\", name: \"Johansson\" },\n      { value: \"other\", name: \"Something else...\"}\n    ]\n  }\n]\n\n\n\n\nStandard Options\n\u00b6\n\n\nGeneral options most field types can handle:\n\n\n{\n  key: \"address.street\",      // The dot notatin to the attribute on the model\n  type: \"text\",               // Type of field\n  title: \"Street\",            // Title of field, taken from schema if available\n  notitle: false,             // Set to true to hide title\n  description: \"Street name\", // A description, taken from schema if available, can be HTML\n  validationMessage: \"Oh noes, please write a proper address\",  // A custom validation error message\n  onChange: \"valueChanged(form.key,modelValue)\", // onChange event handler, expression or function\n  feedback: false,             // Inline feedback icons\n  disableSuccessState: false,  // Set true to NOT apply 'has-success' class to a field that was validated successfully\n  disableErrorState: false,    // Set true to NOT apply 'has-error' class to a field that failed validation\n  placeholder: \"Input...\",     // placeholder on inputs and textarea\n  ngModelOptions: { ... },     // Passed along to ng-model-options\n  readonly: true,              // Same effect as readOnly in schema. Put on a fieldset or array\n                               // and their items will inherit it.\n  htmlClass: \"street foobar\",  // CSS Class(es) to be added to the container div\n  fieldHtmlClass: \"street\"     // CSS Class(es) to be added to field input (or similar)\n  labelHtmlClass: \"street\"     // CSS Class(es) to be added to the label of the field (or similar)\n  copyValueTo: [\"address.street\"],     // Copy values to these schema keys.\n  condition: \"person.age < 18\" // Show or hide field depending on an angular expression\n  destroyStrategy: \"remove\"    // One of \"null\", \"empty\" , \"remove\", or 'retain'. Changes model on $destroy event. default is \"remove\".\n}\n\n\n\n\nonChange\n\u00b6\n\n\nThe \nonChange\n option can be used with most fields and its value should be\neither an angular expression, as a string, or a function. If its an expression\nit will be evaluated in the parent scope of the \nsf-schema\n directive with\nthe special locals \nmodelValue\n and \nform\n. If its a function that will\nbe called with  \nmodelValue\n and \nform\n as first and second arguments.\n\n\nex.\n\n\n$scope.form = [\n  {\n    key: \"name\",\n    onChange: \"updated(modelValue,form)\"\n  },\n  {\n    key: \"password\",\n    onChange: function(modelValue,form) {\n      console.log(\"Password is\",modelValue);\n    }\n  }\n];\n\n\n\n\nValidation Messages\n\u00b6\n\n\nThe validation message can be a string, an object with error codes as key and messages as values\nor a custom message function, see \nValidation Messages\n for the details.\n\n\nInline feedback icons\n\u00b6\n\n\ninput\n and \ntextarea\n based fields get inline status icons by default. A check\nwhen everything is valid and a cross when there are validation errors.\n\n\nThis can be turned off or configured to other icons. To turn off just\nset \nfeedback\n to false. If set to a string that string is evaluated by\na \nngClass\n in the decorators scope. If not set att all the default value\nis \n{ 'glyphicon': true, 'glyphicon-ok': hasSuccess(), 'glyphicon-remove': hasError() }\n\n\nex. displaying an asterisk on required fields\n\n\n  $sope.form = [\n    {\n      key: \"name\",\n      feedback: \"{ 'glyphicon': true, 'glyphicon-asterisk': form.required && !hasSuccess() && !hasError() ,'glyphicon-ok': hasSuccess(), 'glyphicon-remove': hasError() }\"\n    }\n\n\n\n\nUseful things in the decorators scope are\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhasSuccess()\n\n\ntrue\n if field is valid and not pristine\n\n\n\n\n\n\nhasError()\n\n\ntrue\n if field is invalid and not pristine\n\n\n\n\n\n\nngModel\n\n\nThe controller of the ngModel directive, ex. ngModel.$valid\n\n\n\n\n\n\nform\n\n\nThe form definition for this field\n\n\n\n\n\n\n\n\nngModelOptions\n\u00b6\n\n\nAngular 1.3 introduces a new directive, \nngModelOptions\n, which let\u2019s you set\na couple of options that change how the directive \nng-model\n works. Schema Form\nuses \nng-model\n to bind against fields and therefore changing theses options\nmight be usefule for you.\n\n\nOne thing you can do is to change the update behavior of \nng-model\n, this is how\nyou get form fields that validate on blur instead of directly on change.\n\n\nEx.\n\n\n{\n  key: \"email\",\n  ngModelOptions: { updateOn: 'blur' }\n}\n\n\n\n\nSee \nGlobal Options\n for an example how you set entire form\nto validate on blur.\n\n\ncopyValueTo\n\u00b6\n\n\nThis option has a very specific use case. Imagine you have the same option in several places, but you want them to be controlled from just one field. You specify what keys the value should be copied to, and the \nviewValue\n will be copied to these keys on the model. \nNote: changing the model directly will not copy the value, it\u2019s intended for copying user input\n. The recieving fields can be shown, but the intent for them is to be hidden.\n\n\nEx.\n\n\n{\n  key: \"email.main\",\n  copyValueTo: [\"email.confirm\", \"other.email\"]\n}\n\n\n\n\ncondition\n\u00b6\n\n\nThe \ncondition\n option lets you hide or show a field depending on an angular expression. Beneath\nthe surface it uses \nng-if\n so the hidden field is \nnot\n part of the form.\n\n\ncondition\n should be a string with an angular expression. If that expression evaluates as thruthy\nthe field will be rendered into the DOM otherwise not. The expression is evaluated in the parent scope of\nthe \nsf-schema\n directive (the same as onClick on buttons) but with access to the current model,\ncurrent model value and current array index under the name \nmodel\n, \nmodelValue\n and \narrayIndex\n.\nThis is useful for hiding/showing parts of a form depending on another form control.\n\n\nex. A checkbox that shows an input field for a code when checked\n\n\nfunction FormCtrl($scope) {\n  $scope.person = {}\n\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"name\": {\n        \"type\": \"string\",\n        \"title\": \"Name\"\n      },\n      \"eligible\": {\n        \"type\": \"boolean\",\n        \"title\": \"Eligible for awesome things\"\n      },\n      \"code\": {\n        \"type\":\"string\"\n        \"title\": \"The Code\"\n      }\n    }\n  }\n\n  $scope.form = [\n    \"name\",\n    \"eligible\",\n    {\n      \"key\": \"code\",\n      \"condition\": \"person.eligible\", //or \"model.eligible\"\n    }\n  ]\n}\n\n\n\n\nNote that angulars two-way binding automatically will update the conditional field, no need for\nevent handlers and such. The condition need not reference a model value it could be anything on\nscope.\n\n\nThe same example, but inside an array:\n\n\nfunction FormCtrl($scope) {\n  $scope.persons = []\n\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"persons\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": {\n              \"type\": \"string\",\n              \"title\": \"Name\"\n            },\n            \"eligible\": {\n              \"type\": \"boolean\",\n              \"title\": \"Eligible for awesome things\"\n            },\n            \"code\": {\n              \"type\":\"string\"\n              \"title\": \"The Code\"\n            }\n          }\n        }\n      }\n    }\n  }\n\n  $scope.form = [\n    {\n      \"key\": \"persons\",\n      \"items\": [\n        \"persons[].name\",\n        \"persons[].eligible\",\n        {\n          key: \"persons[].code\",\n          condition: \"persons[arrayIndex].eligible\", //or \"model[arrayIndex].eligable\"\n        }\n      ]\n    }\n  ]\n}\n\n\n\n\nNote that arrays inside arrays won\u2019t work with conditions.\n\n\ndestroyStrategy\n\u00b6\n\n\nBy default, when a field is removed from the DOM and the \n$destroy\n event is broadcast, this happens\nif you use the \ncondition\n option, the schema-validate directive will update the model to set the\nfield value to \nundefined\n. This can be overridden by setting the destroyStrategy on a field, or as a\nglobal option, to one of the strings \n\"null\"\n, \n\"empty\"\n , \n\"remove\"\n, or \n\"retain\"\n.\n\n\n\"null\"\n means that model values will be set to \nnull\n instead of being removed.\n\n\n\"empty\"\n means empty strings, \n\"\"\n, for model values that has the \nstring\n type, \n{}\n for model\n  values with \nobject\n type and \n[]\n for \narray\n type. All other types will be treated as \n\"remove\"\n.\n\n\n\"remove\"\n deletes the property. This is the default.\n\n\n\"retain\"\n keeps the value of the property event though the field is no longer in the form or being\nvaidated before submit.\n\n\nIf you\u2019d like to set the destroyStrategy for\nan entire form, add it to the \nglobalOptions\n\n\nSpecific options and types\n\u00b6\n\n\ninput group addons\n\u00b6\n\n\ninput\n and \ntextarea\n types can also have\n\nbootstrap input groups\n.\n\n\nYou can add them with the option \nfieldAddonLeft\n and \nfieldAddonRight\n which both takes a snippet\nof html.\n\n\n[\n  {\n    \"key\": \"email\"\n    \"fieldAddonLeft\": \"@\"\n  }\n]\n\n\n\n\nfieldset and section\n\u00b6\n\n\nfieldset\n and \nsection\n doesn\u2019t need a key. You can create generic groups with them.\nThey do need a list of \nitems\n to have as children.\n\n\n{\n  type: \"fieldset\",\n  items: [\n    \"name\",\n    { key: \"surname\", notitle: true }\n  ]\n}\n\n\n\n\nselect and checkboxes\n\u00b6\n\n\nselect\n and \ncheckboxes\n can take an attribute, \ntitleMap\n, which defines a name\nand a value. The value is bound to the model while the name is used for display.\nIn the case of \ncheckboxes\n the names of the titleMap can be HTML.\n\n\nA \ntitleMap\n can be specified as either an object (same as in JSON Form), where\nthe propery is the value and the value of that property is the name, or as\na list of name-value objects. The latter is used internally and is the recomended\nformat to use. Note that when defining a \ntitleMap\n as an object the value is\nrestricted to strings since property names of objects always is a string.\n\n\nAs a list:\n\n\n{\n  type: \"select\",\n  titleMap: [\n    { value: \"yes\", name: \"Yes I do\" },\n    { value: \"no\", name: \"Hell no\" }\n  ]\n}\n\n\n\n\nAs an object:\n\n\n{\n  type: \"select\",\n  titleMap: {\n    \"yes\": \"Yes I do\",\n    \"no\": \"Hell no\"\n  }\n}\n\n\n\n\nThe \nselect\n can also take an optional \ngroup\n property in its \ntitleMap\n that adds \n<optgroup>\n\nelement to the select.\n\n\n{\n  type: \"select\",\n  titleMap: [\n    { value: \"yes\", name: \"Yes I do\", group: \"Boolean\" },\n    { value: \"no\", name: \"Hell no\" , group: \"Boolean\" },\n    { value: \"no\", name: \"File Not Found\", group: \"Other\" },\n  ]\n}\n\n\n\n\nactions\n\u00b6\n\n\nactions\n behaves the same as fieldset, but can only handle buttons and submits as children.\n\n\n{\n  type: \"actions\",\n  items: [\n    { type: 'submit', title: 'Ok' }\n    { type: 'button', title: 'Cancel', onClick: \"cancel()\" }\n  ]\n}\n\n\n\n\nThe submit and other buttons have btn-default as default.\nWe can change this with \nstyle\n attribute:\n\n\n{\n  type: \"actions\",\n  items: [\n    { type: 'submit', style: 'btn-success', title: 'Ok' }\n    { type: 'button', style: 'btn-info', title: 'Cancel', onClick: \"cancel()\" }\n  ]\n}\n\n\n\n\nbutton and submit\n\u00b6\n\n\nbutton\n and \nsubmit\n can have a \nonClick\n attribute that either a function \nor\n a\nstring with an angular expression, as with ng-click. The expression is evaluated in the parent scope of\nthe \nsf-schema\n directive.\n\n\n[\n  { type: 'submit', title: 'Ok', onClick: function(){ ...  } }\n  { type: 'button', title: 'Cancel', onClick: \"cancel()\" }\n[\n\n\n\n\nThe submit and other buttons have btn-default as default.\nWe can change this with \nstyle\n attribute:\n\n\n[\n  { type: 'submit', style: 'btn-warning', title: 'Ok', onClick: function(){ ...  } }\n  { type: 'button', style: 'btn-danger', title: 'Cancel', onClick: \"cancel()\" }\n[\n\n\n\n\nA \nbutton\n can also have optional icon classes:\n\n\n[\n  {\n    type: 'button',\n    title: 'Cancel',\n    icon: 'glyphicon glyphicon-icon-exclamation-sign'\n    onClick: \"cancel()\"\n  }\n[\n\n\n\n\nradios and radiobuttons\n\u00b6\n\n\nBoth type \nradios\n and \nradiobuttons\n work the same way.\nThey take a \ntitleMap\n and renders ordinary radio buttons or bootstrap 3 buttons\ninline. It\u2019s a cosmetic choice.\n\n\nThe \ntitleMap\n is either a list or an object, see \nselect and checkboxes\n\nfor details. The \u201cname\u201d part in the \ntitleMap\n can be HTML.\n\n\nEx.\n\n\nfunction FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      choice: {\n        type: \"string\",\n        enum: [\"one\",\"two\"]\n      }\n    }\n  };\n\n  $scope.form = [\n    {\n      key: \"choice\",\n      type: \"radiobuttons\",\n      titleMap: [\n        { value: \"one\", name: \"One\" },\n        { value, \"two\", name: \"More...\" }\n      ]\n    }\n  ];\n}\n\n\n\n\nThe actual schema property it binds doesn\u2019t need to be a string with an enum.\nHere is an example creating a yes no radio buttons that binds to a boolean.\n\n\nEx.\n\n\nfunction FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      confirm: {\n        type: \"boolean\",\n        default: false\n      }\n    }\n  };\n\n  $scope.form = [\n    {\n      key: \"confirm\",\n      type: \"radios\",\n      titleMap: [\n        { value: false, name: \"No I don't understand these cryptic terms\" },\n        { value: true, , name: \"Yes this makes perfect sense to me\" }\n      ]\n    }\n  ];\n}\n\n\n\n\nWith \nradiobuttons\n, both selected and unselected buttons have btn-default as default.\nWe can change this with \nstyle\n attribute:\n\n\nfunction FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      choice: {\n        type: \"string\",\n        enum: [\"one\",\"two\"]\n      }\n    }\n  };\n\n  $scope.form = [\n    {\n      key: \"choice\",\n      type: \"radiobuttons\",\n      style: {\n        selected: \"btn-success\",\n        unselected: \"btn-default\"\n      },\n      titleMap: [\n     { value: \"one\", name: \"One\" },\n     { value, \"two\", name: \"More...\" }\n   ]\n  ];\n}\n\n\n\n\nhelp\n\u00b6\n\n\nHelp fields is not really a field, but instead let\u2019s you insert arbitrary HTML\ninto a form, suitable for help texts with links etc.\n\n\nThe get a help field you need to specify the type \nhelp\n and have a html\nsnippet as a string in the option \nhelpvalue\n\n\nEx.\n\n\nfunction FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      name: {\n        title: \"Name\",\n        type: \"string\"\n      }\n    }\n  };\n\n  $scope.form = [\n    {\n      type: \"help\",\n      helpvalue: \"<h1>Yo Ninja!</h1>\"\n    },\n    \"name\"\n  ];\n}\n\n\n\n\ntemplate\n\u00b6\n\n\ntemplate\n fields are like \nhelp\n fields but instead of arbitrary html you can insert or refer to\nan angular template to be inserted where the field should go. There is one catch though and that\nis that the scope is that of the decorator directive and its inside the isolated scope of the\n\nsf-schema\n directive, so anything you like to access in the template should be put on the form,\nwhich is available in template. It\u2019s basically a simple one shot version of add-ons, so see the\nsee the docs on \nExtending Schema Form\n for details on what is on scope and what\u2019s up\nwith \n$$value$$\n\n\nThe \ntemplate\n type should either have a \ntemplate\n or a \ntemplateUrl\n option.\n\n\nEx.\n\n\nfunction FormCtrl($scope) {\n\n  $scope.form = [\n    {\n      type: \"template\",\n      template: '<h1 ng-click=\"form.foo()\">Yo {{form.name}}!</h1>',\n      name: 'Ninja',\n      foo: function() { console.log('oh noes!'); }\n    },\n    {\n      type: \"template\",\n      templateUrl: \"templates/foo.html\",\n      myFavouriteVariable: 'OMG!!'\n    }\n  ];\n}\n\n\n\n\ntabs\n\u00b6\n\n\nThe \ntabs\n form type lets you split your form into tabs. It is similar to\n\nfieldset\n in that it just changes the presentation of the form. \ntabs\n\ntakes a option, also called \ntabs\n, that is a list of tab objects. Each tab\nobject consist of a \ntitle\n and a \nitems\n list of form objects.\n\n\nEx.\n\n\nfunction FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      name: {\n        title: \"Name\",\n        type: \"string\"\n      },\n      nick: {\n        title: \"Nick\",\n        type: \"string\"\n      }\n      alias: {\n        title: \"Alias\",\n        type: \"string\"\n      }\n      tag: {\n        title: \"Tag\",\n        type: \"string\"\n      }\n    }\n  };\n\n  $scope.form = [\n    \"name\",\n    {\n      type: \"tabs\",\n      tabs: [\n        {\n          title: \"Tab 1\",\n          items: [\n            \"nick\",\n            \"alias\"\n          ]\n        },\n        {\n          title: \"Tab 2\",\n          items: [\n            \"tag\"\n          ]\n        }\n      ]\n    }\n  ];\n}\n\n\n\n\narray\n\u00b6\n\n\nThe \narray\n form type is the default for the schema type \narray\n.\nThe schema for an array has the property \n\"items\"\n which in the JSON Schema\nspecification can be either another schema (i.e. and object), or a list of\nschemas. Only a schema is supported by Schema Form, and not the list of schemas.\n\n\nThe \nform\n definition has the option \nitems\n that should be a list\nof form objects.\n\n\nThe rendered list of subforms each have a \n\u201cRemove\u201d\n button and at the bottom there\nis an \n\u201cAdd\u201d\n button. The default \n\u201cAdd\u201d\n button has class btn-default and text Add. Both\ncould be changed using attribute \nadd\n, see example below.\n\n\nIf you like to have drag and drop reordering of arrays you also need\n\nui-sortable\n and its dependencies\n\njQueryUI\n, see \nui-sortable\n documentation for details of\nwhat parts of jQueryUI that is needed. You can safely ignore these if you don\u2019t\nneed the reordering.\n\n\nIn the form definition you can refer to properties of an array item by the empty\nbracket notation. In the \nkey\n simply end the name of the array with \n[]\n\n\nBy default the array will start with one \nundefined\n value so that the user is presented with one\nform element. To suppress this behaviour, set the attribute \nstartEmpty\n to \ntrue\n.\n\n\nGiven the schema:\n\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"subforms\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": { \"type\": \"string\" },\n          \"nick\": { \"type\": \"string\" },\n          \"emails\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n\n\nThen \nsubforms[].name\n refers to the property name of any subform item,\n\nsubforms[].emails[]\n refers to the subform of emails. See example below for\nusage.\n\n\nSingle list of inputs example:\n\n\nfunction FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      names: {\n        type: \"array\",\n        items: {\n          title: \"Name\",\n          type: \"string\"\n        }\n      }\n    }\n  };\n\n  $scope.form = ['*'];\n}\n\n\n\n\nExample with sub form, note that you can get rid of the form field the object wrapping the\nsubform fields gives you per default by using the \nitems\n option in the\nform definition, also example of \nstartEmpty\n.\n\n\nfunction FormCtrl($scope) {\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"subforms\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": { \"type\": \"string\" },\n            \"nick\": { \"type\": \"string\" },\n            \"emails\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n\n  $scope.form = [\n    {\n      key: \"subforms\",\n      add: \"Add person\",\n      style: {\n        add: \"btn-success\"\n      },\n      items: [\n        \"subforms[].nick\",\n        \"subforms[].name\",\n        \"subforms[].emails\",\n      ],\n      startEmpty: true\n    }\n  ];\n}\n\n\n\n\nTo suppress add and remove buttons set \nadd\n to \nnull\n and \nremove\n to \nnull\n.\n\n\nfunction FormCtrl($scope) {\n  $scope.form = [\n    {\n      key: \"subforms\",\n      add: null,\n      remove: null,\n      style: {\n        add: \"btn-success\"\n      },\n      items: [\n        \"subforms[].nick\",\n        \"subforms[].name\",\n        \"subforms[].emails\",\n      ],\n    }\n  ];\n}\n\n\n\n\ntabarray\n\u00b6\n\n\nThe \ntabarray\n form type behaves the same way and has the same options as\n\narray\n but instead of rendering a list it renders a tab per item in list.\n\n\nBy default the tabs are on the left side (follows the default in JSON Form),\nbut with the option \ntabType\n you can change that to eiter \n\u201ctop\u201d\n or \n\u201cright\u201d\n\nas well.\n\n\nEvery tab page has a \n\u201cRemove\u201d\n button. The default \n\u201cRemove\u201d\n button has class btn-default\nand text Remove. Both could be changed using attribute \nremove\n, see example below.\n\n\nIn this case we have an \n\u201cAdd\u201d\n link, not an \n\u201cAdd\u201d\n button. Therefore, the attribute \nadd\n\nonly changes the text of the link. See example below.\n\n\nBootstrap 3 doesn\u2019t have side tabs so to get proper styling you need to add the\ndependency \nbootstrap-vertical-tabs\n.\nIt is not needed for tabs on top.\n\n\nThe \ntitle\n option is a bit special in \ntabarray\n, it defines the title\nof the tab and it is interpolated so you can use expression it. Its interpolated\nwith two extra variables in context: \nvalue\n and \n$index\n, where \nvalue\n\nis the value in the array (i.e. that tab) and \n$index\n the index.\n\n\nYou can include multiple expressions or mix expressions and text as needed:\nEx:\n\n\n\n    {\n      \"form\": [\n        {\n          \"type\": \"tabarray\",\n          \"title\": \"My {{ value.name }} is:\",\n        }\n      ]\n    }\n\n\n\n\n\nDeprecation Warning\n\u00b6\n\n\nBefore version 0.8.0 the entire title was evaluated as an expression and not interpolated.\nIf you weren\u2019t using expressions in your form titles then no changes are needed.\n\n\nHowever, if your tabarray titles contain implicit Angular expressions like this:\n\n\n    {\n      \"form\": [\n        {\n          \"type\": \"tabarray\",\n          \"title\": \"value.name || 'Tab '+$index\",\n        }\n      ]\n    }\n\n\n\n\nThen you should change this to explicit expressions by wrapping them with the Angular expression\ndelimiter \u201c{{ }}\u201d:\n\n\n    {\n      \"form\": [\n        {\n          \"type\": \"tabarray\",\n          \"title\": \"{{ value.name || 'Tab '+$index }}\",\n        }\n      ]\n    }\n\n\n\n\nExample with tabs on the top:\n\n\nfunction FormCtrl($scope) {\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"subforms\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": { \"type\": \"string\" },\n            \"nick\": { \"type\": \"string\" },\n            \"emails\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n\n  $scope.form = [\n    {\n      type: \"tabarray\",\n      tabType: \"top\",\n      title: \"{{value.nick || ('Tab '+$index)}}\"\n      key: \"subforms\",\n      remove: \"Delete\",\n      style: {\n        remove: \"btn-danger\"\n      },\n      add: \"Add person\",\n      items: [\n        \"subforms[].nick\",\n        \"subforms[].name\",\n        \"subforms[].emails\",\n      ]\n    }\n  ];\n}\n\n\n\n\nPost process function\n\u00b6\n\n\nIf you like to use \n[\"*\"]\n as a form, or aren\u2019t in control of the form definitions\nbut really need to change or add something you can register a \npost process\n\nfunction with the \nschemaForm\n service provider. The post process function\ngets one argument, the final form merged with the defaults from the schema just\nbefore it\u2019s rendered, and should return a form.\n\n\nEx. Reverse all forms\n\n\nangular.module('myModule', ['schemaForm']).config(function(schemaFormProvider){\n\n  schemaFormProvider.postProcess(function(form){\n    form.reverse();\n    return form;\n  })\n\n});\n\n\n\n\nEvents\n\u00b6\n\n\nEvents are emitted or broadcast at various points in the process of rendering or validating the\nform. Below is a list of these events and how they are propagated.\n\n\n\n\n\n\n\n\nEvent\n\n\nWhen\n\n\nType\n\n\nArguments\n\n\n\n\n\n\n\n\n\n\nsf-render-finished\n\n\nAfter form is rendered\n\n\nemit\n\n\nThe sf-schema directives\u2019s element\n\n\n\n\n\n\n\n\nSchema form also listens to events.\n\n\n\n\n\n\n\n\nEvent\n\n\nWhat\n\n\nDocs\n\n\n\n\n\n\n\n\n\n\nschemaFormValidate\n\n\nValidates all fields\n\n\nHandling Submit\n\n\n\n\n\n\nschemaFormRedraw\n\n\nRedraws form\n\n\nUpdating Form\n\n\n\n\n\n\n\n\nManual field insertion\n\u00b6\n\n\nThere is a limited feature for controlling manually where a generated field should go so you can\n,as an example, wrap it in custom html. Consider the feature experimental.\n\n\nIt has a number of drawbacks though.\n\n\n\n\nYou can only insert fields that are in the root level of your form definition, i.e. not inside fieldset, arrays etc.\n\n\nGenerated fields are always last in the form so if you don\u2019t supply slots for all of your top level fields the rest goes below.\n\n\nTo match \u201ckeys\u201d of forms we match against the internal array format, hence the key \u201cname\u201d becomes \u201c[\u2018name\u2019]\u201d and \u201cfoo.bar\u201d becomes \u201c[\u2018foo\u2019][\u2018bar\u2019]\u201d\n\n\n\n\nDefine \u201cslots\u201d for the generated field by adding an element with the attribute \nsf-insert-field\n\n\nex.\n\n\n$scope.form = [\n  \"name\",\n  \"email\",\n  \"comment\"\n]\n\n\n\n\n<form sf-model=\"model\"\n      sf-form=\"form\"\n      sf-schema=\"schema\">\n  <em>before</em>\n  <div sf-insert-field=\"['email']\"></div>\n  <em>after</em>\n\n  <!-- the rest of the form, i.e. name and comment will be generated here -->\n</form>\n\n\n\n\nDeprecated fields\n\u00b6\n\n\nconditional\n\u00b6\n\n\nThe \nconditional\n type is now deprecated since every form type now supports the form option\n\ncondition\n.\n\n\nA \nconditional\n is exactly the same as a \nsection\n, i.e. a \n<div>\n with other form elements in\nit, hence they need an \nitems\n property. They also need a \ncondition\n which is\na string with an angular expression. If that expression evaluates as thruthy the \nconditional\n\nwill be rendered into the DOM otherwise not. The expression is evaluated in the parent scope of\nthe \nsf-schema\n directive (the same as onClick on buttons) but with access to the current model\nand current array index under the name \nmodel\n and \narrayIndex\n. This is useful for hiding/showing\nparts of a form depending on another form control.\n\n\nex. A checkbox that shows an input field for a code when checked\n\n\nfunction FormCtrl($scope) {\n  $scope.person = {}\n\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"name\": {\n        \"type\": \"string\",\n        \"title\": \"Name\"\n      },\n      \"eligible\": {\n        \"type\": \"boolean\",\n        \"title\": \"Eligible for awesome things\"\n      },\n      \"code\": {\n        \"type\":\"string\"\n        \"title\": \"The Code\"\n      }\n    }\n  }\n\n  $scope.form = [\n    \"name\",\n    \"eligible\",\n    {\n        type: \"conditional\",\n        condition: \"model.person.eligible\",\n        items: [\n          \"code\"\n        ]\n    }\n  ]\n}\n\n\n\n\nNote that angulars two-way binding automatically will update the conditional block, no need for\nevent handlers and such. The condition need not reference a model value it could be anything in\nscope.\n\n\nThe same example, but inside an array:\n\n\nfunction FormCtrl($scope) {\n  $scope.persons = []\n\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"persons\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": {\n              \"type\": \"string\",\n              \"title\": \"Name\"\n            },\n            \"eligible\": {\n              \"type\": \"boolean\",\n              \"title\": \"Eligible for awesome things\"\n            },\n            \"code\": {\n              \"type\":\"string\"\n              \"title\": \"The Code\"\n            }\n          }\n        }\n      }\n    }\n  }\n\n  $scope.form = [\n    {\n      \"key\": \"persons\",\n      \"items\": [\n        \"persons[].name\",\n        \"persons[].eligible\",\n        {\n          type: \"conditional\",\n          condition: \"persons[arrayIndex].eligible\", //or \"model.eligable\"\n          items: [\n            \"persons[].code\"\n          ]\n        }\n      ]\n    }\n  ]\n}\n\n\n\n\nNote that arrays inside arrays won\u2019t work with conditional.",
            "title": "Docs"
        },
        {
            "location": "/#documentation",
            "text": "Basic Usage  Handling Submit  Updating Form  Global Options  Validation Messages  Custom Validation  Inject errors into form, aka backend validation  Using ngModelController  $validators  $asyncVaidators      Form defaults in schema  Form types  Default form types  Form definitions  Overriding field types and order  Standard Options  onChange  Validation Messages  Inline feedback icons  ngModelOptions  copyValueTo    Specific options and types  input group addons  fieldset and section  select and checkboxes  actions  button  radios and radiobuttons  help  template  tabs  array  tabarray    Post process function  Events  Manual field insertion  Deprecated fields  Extending Schema Form",
            "title": "Documentation"
        },
        {
            "location": "/#basic-usage",
            "text": "First, expose your schema, form, and model to the $scope.\nDon\u2019t forget to load the  schemaForm  module.  angular.module('myModule', ['schemaForm'])\n       .controller('FormController', function($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      name: { type: \"string\", minLength: 2, title: \"Name\", description: \"Name or alias\" },\n      title: {\n        type: \"string\",\n        enum: ['dr','jr','sir','mrs','mr','NaN','dj']\n      }\n    }\n  };\n\n  $scope.form = [\n    \"*\",\n    {\n      type: \"submit\",\n      title: \"Save\"\n    }\n  ];\n\n  $scope.model = {};\n}  Then load them into Schema Form using the  sfSchema ,  sfForm , and  sfModel  directives.  <div ng-controller=\"FormController\">\n    <form sf-schema=\"schema\" sf-form=\"form\" sf-model=\"model\"></form>\n</div>  The  sfSchema  directive doesn\u2019t need to be on a form tag, in fact it can be quite useful\nto set it on a div or some such inside the form instead. Especially if you like to prefix or suffix the\nform with buttons or fields that are hard coded.  Example with custom submit buttons:  <div ng-controller=\"FormController\">\n  <form>\n    <p>bla bla bla</p>\n    <div sf-schema=\"schema\" sf-form=\"form\" sf-model=\"model\"></div>\n    <input type=\"submit\" value=\"Submit\">\n    <button type=\"button\" ng-click=\"goBack()\">Cancel</button>\n  </form>\n</div>",
            "title": "Basic Usage"
        },
        {
            "location": "/#handling-submit",
            "text": "Schema Form does not care what you do with your data, to handle form submit\nthe recomended way is to use the  ng-submit  directive. It\u2019s also recomended\nto use a  name  attribute on your form so you can access the FormController \nand check if the form is valid or not.  You can force a validation by broadcasting the event  schemaFormValidate , ex $scope.$broadcast('schemaFormValidate') , this will immediately validate the\nentire form and show any errors.  Example submit:  function FormController($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      name: { type: \"string\", minLength: 2, title: \"Name\", description: \"Name or alias\" },\n      title: {\n        type: \"string\",\n        enum: ['dr','jr','sir','mrs','mr','NaN','dj']\n      }\n    }\n  };\n\n  $scope.form = [\n    \"*\",\n    {\n      type: \"submit\",\n      title: \"Save\"\n    }\n  ];\n\n  $scope.model = {};\n\n  $scope.onSubmit = function(form) {\n    // First we broadcast an event so all fields validate themselves\n    $scope.$broadcast('schemaFormValidate');\n\n    // Then we check if the form is valid\n    if (form.$valid) {\n      // ... do whatever you need to do with your data.\n    }\n  }\n}  And the HTML would be something like this:  <div ng-controller=\"FormController\">\n    <form name=\"myForm\"\n          sf-schema=\"schema\"\n          sf-form=\"form\"\n          sf-model=\"model\"\n          ng-submit=\"onSubmit(myForm)\"></form>\n</div>",
            "title": "Handling Submit"
        },
        {
            "location": "/#updating-form",
            "text": "Schema Form watches  sf-form  and  sf-schema  and will redraw the form if one or both changes, but\nonly if they change completly, i.e. not the same object and/or form instance. For performance\nreasons we have opted to not watch schema and form deeply. So if you have updated a part of the\nschema or the form definition you can trigger a redraw by issuing the event  schemaFormRedraw .  ex:  function Ctrl($scope) {\n  $scope.removeLastField = function() {\n    $scope.form.pop()\n    $scope.$broadcast('schemaFormRedraw')\n  }\n}",
            "title": "Updating Form"
        },
        {
            "location": "/#global-options",
            "text": "Schema Form also have two options you can set globally via the  sf-options \nattribute which should be placed along side  sf-schema .  sf-options  takes an object with the following possible attributes.     Attribute  Type       supressPropertyTitles  boolean  by default schema form uses the property name in the schema as a title if none is specified, set this to true to disable that behavior    formDefaults  object  an object that will be used as a default for all form definitions    validationMessage  object or function  Object or a function that will be used as default validation message for all fields. See  Validation Messages  for details.    setSchemaDefaults  boolean  Should schema defaults be set on model.    destroyStrategy  string  the default strategy to use for cleaning the model when a form element is removed. see  destroyStrategy  below    pristine  Object  {errors ,success}  Sets if errors and success states should be visible when form field are  $pristine . Default is  {errors: true, success: true}    validateOnRender  boolean  Should form be validated on initial render? Default  false     formDefaults  is mostly useful for setting global  ngModelOptions \ni.e. changing the entire form to validate on blur.  Ex.  <div ng-controller=\"FormController\">\n    <form sf-schema=\"schema\"\n          sf-form=\"form\"\n          sf-model=\"model\"\n          sf-options=\"{ formDefaults: { ngModelOptions: { updateOn: 'blur' } }}\"></form>\n</div>",
            "title": "Global Options"
        },
        {
            "location": "/#validation-messages",
            "text": "We use  tv4  to validate the form and all of the\nvalidation messages match up  tv4 error codes .  There are several ways to change the default validation messages.   Change the defaults in  sfErrorMessages  service via its provider. This will set the validation\n     messages for all instances of  sf-schema  Use the global option  validationMessage  Use the form field option  validationMessage   If a specific validation error code can\u2019t be found in the form field option, schema form looks at\nthe global option, if none is there it looks at it\u2019s own defaults and if all fails it will instead\nuse the the message under the error code  'default'  Ex of form field option.  var form = [\n  \"address.zip\",\n  {\n    key: \"address.street\",\n    validationMessage: {\n      302: \"This field is like, uh, required?\"\n    }\n  }\n];  And of global options  <div ng-controller=\"FormController\">\n    <form sf-schema=\"schema\"\n          sf-form=\"form\"\n          sf-model=\"model\"\n          sf-options=\"{ validationMessage: { 302: 'Do not forget me!' }}\"></form>\n</div>",
            "title": "Validation Messages"
        },
        {
            "location": "/#message-interpolation",
            "text": "Having a good validation message is hard, sometimes you need to reference the actual value, title,\nor constraint that you hit. Schema Form supports interpolation of error messages to make this a\nlittle bit easier.  The context variables available to you are:     Name  Value      error  The error code    title  Title of the field    value  The model value    viewValue  The view value (probably the one you want)    form  form definition object for this field    schema  schema for this field     Ex.\n  javascript\n var form = [\n   \"address.zip\",\n   {\n     key: \"address.street\",\n     validationMessage: {\n       101: 'Seriously? Value {{value}} totally less than {{schema.minimum}}, which is NOT OK.',\n     }\n   }\n ];",
            "title": "Message Interpolation"
        },
        {
            "location": "/#taking-over-functions-as-validationmessages",
            "text": "If you really need to control the validaton messages and interpolation is not enough (like say\nyour using  Jed  for gettext translations) you can supply a\nfunction instead of a particular message or the entire validationMessage object.  The should take one argument, and that is an object with the exact same properties as the context\nused for interpolation, see table above.  Ex.  var form = [\n  \"address.zip\",\n  {\n    key: \"address.street\",\n    validationMessage: {\n      302: function(ctx) { return Jed.gettext('This value is required.'); },\n    }\n  }\n];  Or:  var form = [\n  \"address.zip\",\n  {\n    key: \"address.street\",\n    validationMessage: function(ctx) {\n      return lookupMessage[ctx.error];\n    }\n  }\n];",
            "title": "Taking over: functions as validationMessages"
        },
        {
            "location": "/#custom-validation",
            "text": "Sometimes the validation you want is tricky to express in a JSON Schema\nor Schema Form does not support it (yet), like  anyOf  and  oneOf .  Other times you really need to ask the backend, maybe to check that the a username is not already\ntaken or some other constraint that only the backend can know about.",
            "title": "Custom Validation"
        },
        {
            "location": "/#inject-errors-into-form-aka-backend-validation",
            "text": "To support validation outside of the form, most commonly on the backend, schema form lets you\ninjecting arbitrary validationMessages to any field and setting it\u2019s validity.  This is done via an event that starts with  schemaForm.error.  and ends with the key to the field.\nIt also takes two arguments, the first being the error code, the second being either a\nvalidation message or a boolean that sets validity, specifying a validation message automatically\nsets the field to invalid.  So lets do an example, say you have a form with a text field  name :  Schema  {\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": { \"type\": \"string\" }\n  }\n}  Form  [\n  \"name\"\n]  To inject an error message and set that forms validity via  ngModelController.$setValidity \nbroadcast an event with the name  schemaForm.error.name  with name/code for the error and an\noptional validation message.  scope.$broadcast('schemaForm.error.name','usernameAlreadyTaken','The username is already taken');  This will invalidate the field and therefore the form and show the error message where it normally\npops up, under the field for instance.  There is a catch though, schema form can\u2019t know when this field is valid so you have to tell it by\nsending an event again, this time switch out the validation message for validity of the field,\ni.e.  true .  scope.$broadcast('schemaForm.error.name','usernameAlreadyTaken',true);  You can also pre-populate the validation messages if you don\u2019t want to send them in the event.  Form  [\n  {\n    \"key\": \"name\",\n    \"validationMessages\": {\n      \"userNameAlreadyTaken\"\n    }\n  }\n]  scope.$broadcast('schemaForm.error.name','usernameAlreadyTaken',false);  You can even trigger standard tv4 error messages, just prefix the error code with  tv4-  // Shows the \"Required\" error message\nscope.$broadcast('schemaForm.error.name','tv4-302',false);",
            "title": "Inject errors into form aka backend validation"
        },
        {
            "location": "/#using-ngmodelcontroller",
            "text": "Another way to validate your fields is to use Angulars built in support for validator functions\nand async validators via the  ngModelController  Schema Form can expose the  ngModelController  on a field for a function supplied with the form\ndefinition. Or you can use a shorthand by adding  $validators  and  $asyncValidators  objects as\nwell as  $viewChangeListener ,  $parsers  and  $formatters  arrays to your form object and they\nwill be picked up.  Note that  $validators  and  $asyncValidators  are Angular 1.3+ only.  See Angular docs for details and there is also an example you can look at here examples/custom-validators.html",
            "title": "Using ngModelController"
        },
        {
            "location": "/#validators",
            "text": "Custom validator functions are added to the  $validators  object and their attribute name is the\nerror code, so to specify a error message you also need to use.  [\n  {\n    key: 'name',\n    validationMessage: {\n      'noBob': 'Bob is not OK! You here me?'\n    },\n    $validators: {\n      noBob: function(value) {\n        if (angular.isString(value) && value.indexOf('Bob') !== -1) {\n          return false;\n        }\n        return true\n      }\n    }\n  }\n]",
            "title": "$validators"
        },
        {
            "location": "/#asyncvalidators",
            "text": "Async validators are basically the same as their synchronous counterparts, but instead you return\na promise that resolves or rejects.  [\n  {\n    key: 'name',\n    validationMessage: {\n      'noBob': 'Bob is not OK! You here me?'\n    },\n    $asyncValidators: {\n      noBob: function(value) {\n        var deferred = $q.defer();\n        $timeout(function(){\n          if (angular.isString(value) && value.indexOf('bob') !== -1) {\n            deferred.reject();\n          } else {\n            deferred.resolve();\n          }\n        }, 500);\n        return deferred.promise;\n      }\n    }\n  }\n]",
            "title": "$asyncValidators"
        },
        {
            "location": "/#form-defaults-in-schema",
            "text": "Its recommended to split presentation and validation into a form definition and a json schema. But\nif you for some reason can\u2019t do this, but  do  have the power to change the schema, you can supply form\ndefault values within the schema using the custom attribute  x-schema-form .  x-schema-form  should\nbe a form object and acts as form definition defaults for that field.  Example schema.  {\n  \"type\": \"object\",\n  \"properties\": {\n    \"comment\": {\n      \"type\": \"string\",\n      \"title\": \"Comment\",\n      \"x-schema-form\": {\n        \"type\": \"textarea\",\n        \"placeholder\": \"Don't hold back\"\n      }\n    }\n  }\n}",
            "title": "Form defaults in schema"
        },
        {
            "location": "/#form-types",
            "text": "Schema Form currently supports the following form field types out of the box:     Form Type  Becomes      fieldset  a fieldset with legend    section  just a div    actions  horizontal button list, can only submit and buttons as items    text  input with type text    textarea  a textarea    number  input type number    password  input type password    checkbox  a checkbox    checkboxes  list of checkboxes    select  a select (single value)    submit  a submit button    button  a button    radios  radio buttons    radios-inline  radio buttons in one line    radiobuttons  radio buttons with bootstrap buttons    help  insert arbitrary html    template  insert an angular template    tab  tabs with content    array  a list you can add, remove and reorder    tabarray  a tabbed version of array     More field types can be added, for instance a \u201cdatepicker\u201d type can be added by\nincluding the  datepicker addon , see\nthe  front page  for an updated\nlist.",
            "title": "Form types"
        },
        {
            "location": "/#default-form-types",
            "text": "Schema Form defaults to certain types of form fields depending on the schema for\na property.     Schema  Form type      \u201ctype\u201d: \u201cstring\u201d  text    \u201ctype\u201d: \u201cnumber\u201d  number    \u201ctype\u201d: \u201cinteger\u201d  number    \u201ctype\u201d: \u201cboolean\u201d  checkbox    \u201ctype\u201d: \u201cobject\u201d  fieldset    \u201ctype\u201d: \u201cstring\u201d and a \u201cenum\u201d  select    \u201ctype\u201d: \u201carray\u201d and a \u201cenum\u201d in array type  checkboxes    \u201ctype\u201d: \u201carray\u201d  array",
            "title": "Default form types"
        },
        {
            "location": "/#form-definitions",
            "text": "If you don\u2019t supply a form definition, it will default to rendering the after the defaults taken\nfrom the schema.  A form definition is a list where the items can be\n  * A star,  \"*\" \n  * A string with the dot notated name/path to a property,  \"name\" \n  * An object with that defines the options for a form field.,  { key: \"name\" }  The star,  \"*\"  means \u201cuse the default for the entire schema\u201d and is useful when you want the\ndefaults plus an additional button.  ex.  [\n  \"*\",\n  { type: 'submit', title: 'Save' }\n]  The string notation,  \"name\" ,  is just a shortcut for the object notation  { key: \"name\" } \nwhere key denotes what part of the schema we\u2019re creating a form field for.",
            "title": "Form definitions"
        },
        {
            "location": "/#overriding-field-types-and-order",
            "text": "The order of the fields is technically undefined since the order of attributes on an javascript\nobject (which the schema ends up being) is undefined. In practice it kind of works though.\nIf you need to override the order of the forms, or just want to be sure, specify a form definition.  ex.  var schema = {\n  \"type\": \"object\",\n  \"properties\": {\n    \"surname\":     { \"type\": \"string\" },\n    \"firstname\":   { \"type\": \"string\" },\n  }\n}\n\n[\n  \"firstname\",\n  \"surname\"\n]  You can also override fields to force the type and supply other options:\nex.  var schema = {\n  \"type\": \"object\",\n  \"properties\": {\n    \"surname\":     { \"type\": \"string\" },\n    \"firstname\":   { \"type\": \"string\" },\n  }\n}\n\n[\n  \"firstname\",\n  {\n    key: \"surname\",\n    type: \"select\",\n    titleMap: [\n      { value: \"Andersson\", name: \"Andersson\" },\n      { value: \"Johansson\", name: \"Johansson\" },\n      { value: \"other\", name: \"Something else...\"}\n    ]\n  }\n]",
            "title": "Overriding field types and order"
        },
        {
            "location": "/#standard-options",
            "text": "General options most field types can handle:  {\n  key: \"address.street\",      // The dot notatin to the attribute on the model\n  type: \"text\",               // Type of field\n  title: \"Street\",            // Title of field, taken from schema if available\n  notitle: false,             // Set to true to hide title\n  description: \"Street name\", // A description, taken from schema if available, can be HTML\n  validationMessage: \"Oh noes, please write a proper address\",  // A custom validation error message\n  onChange: \"valueChanged(form.key,modelValue)\", // onChange event handler, expression or function\n  feedback: false,             // Inline feedback icons\n  disableSuccessState: false,  // Set true to NOT apply 'has-success' class to a field that was validated successfully\n  disableErrorState: false,    // Set true to NOT apply 'has-error' class to a field that failed validation\n  placeholder: \"Input...\",     // placeholder on inputs and textarea\n  ngModelOptions: { ... },     // Passed along to ng-model-options\n  readonly: true,              // Same effect as readOnly in schema. Put on a fieldset or array\n                               // and their items will inherit it.\n  htmlClass: \"street foobar\",  // CSS Class(es) to be added to the container div\n  fieldHtmlClass: \"street\"     // CSS Class(es) to be added to field input (or similar)\n  labelHtmlClass: \"street\"     // CSS Class(es) to be added to the label of the field (or similar)\n  copyValueTo: [\"address.street\"],     // Copy values to these schema keys.\n  condition: \"person.age < 18\" // Show or hide field depending on an angular expression\n  destroyStrategy: \"remove\"    // One of \"null\", \"empty\" , \"remove\", or 'retain'. Changes model on $destroy event. default is \"remove\".\n}",
            "title": "Standard Options"
        },
        {
            "location": "/#onchange",
            "text": "The  onChange  option can be used with most fields and its value should be\neither an angular expression, as a string, or a function. If its an expression\nit will be evaluated in the parent scope of the  sf-schema  directive with\nthe special locals  modelValue  and  form . If its a function that will\nbe called with   modelValue  and  form  as first and second arguments.  ex.  $scope.form = [\n  {\n    key: \"name\",\n    onChange: \"updated(modelValue,form)\"\n  },\n  {\n    key: \"password\",\n    onChange: function(modelValue,form) {\n      console.log(\"Password is\",modelValue);\n    }\n  }\n];",
            "title": "onChange"
        },
        {
            "location": "/#validation-messages_1",
            "text": "The validation message can be a string, an object with error codes as key and messages as values\nor a custom message function, see  Validation Messages  for the details.",
            "title": "Validation Messages"
        },
        {
            "location": "/#inline-feedback-icons",
            "text": "input  and  textarea  based fields get inline status icons by default. A check\nwhen everything is valid and a cross when there are validation errors.  This can be turned off or configured to other icons. To turn off just\nset  feedback  to false. If set to a string that string is evaluated by\na  ngClass  in the decorators scope. If not set att all the default value\nis  { 'glyphicon': true, 'glyphicon-ok': hasSuccess(), 'glyphicon-remove': hasError() }  ex. displaying an asterisk on required fields    $sope.form = [\n    {\n      key: \"name\",\n      feedback: \"{ 'glyphicon': true, 'glyphicon-asterisk': form.required && !hasSuccess() && !hasError() ,'glyphicon-ok': hasSuccess(), 'glyphicon-remove': hasError() }\"\n    }  Useful things in the decorators scope are     Name  Description      hasSuccess()  true  if field is valid and not pristine    hasError()  true  if field is invalid and not pristine    ngModel  The controller of the ngModel directive, ex. ngModel.$valid    form  The form definition for this field",
            "title": "Inline feedback icons"
        },
        {
            "location": "/#ngmodeloptions",
            "text": "Angular 1.3 introduces a new directive,  ngModelOptions , which let\u2019s you set\na couple of options that change how the directive  ng-model  works. Schema Form\nuses  ng-model  to bind against fields and therefore changing theses options\nmight be usefule for you.  One thing you can do is to change the update behavior of  ng-model , this is how\nyou get form fields that validate on blur instead of directly on change.  Ex.  {\n  key: \"email\",\n  ngModelOptions: { updateOn: 'blur' }\n}  See  Global Options  for an example how you set entire form\nto validate on blur.",
            "title": "ngModelOptions"
        },
        {
            "location": "/#copyvalueto",
            "text": "This option has a very specific use case. Imagine you have the same option in several places, but you want them to be controlled from just one field. You specify what keys the value should be copied to, and the  viewValue  will be copied to these keys on the model.  Note: changing the model directly will not copy the value, it\u2019s intended for copying user input . The recieving fields can be shown, but the intent for them is to be hidden.  Ex.  {\n  key: \"email.main\",\n  copyValueTo: [\"email.confirm\", \"other.email\"]\n}",
            "title": "copyValueTo"
        },
        {
            "location": "/#condition",
            "text": "The  condition  option lets you hide or show a field depending on an angular expression. Beneath\nthe surface it uses  ng-if  so the hidden field is  not  part of the form.  condition  should be a string with an angular expression. If that expression evaluates as thruthy\nthe field will be rendered into the DOM otherwise not. The expression is evaluated in the parent scope of\nthe  sf-schema  directive (the same as onClick on buttons) but with access to the current model,\ncurrent model value and current array index under the name  model ,  modelValue  and  arrayIndex .\nThis is useful for hiding/showing parts of a form depending on another form control.  ex. A checkbox that shows an input field for a code when checked  function FormCtrl($scope) {\n  $scope.person = {}\n\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"name\": {\n        \"type\": \"string\",\n        \"title\": \"Name\"\n      },\n      \"eligible\": {\n        \"type\": \"boolean\",\n        \"title\": \"Eligible for awesome things\"\n      },\n      \"code\": {\n        \"type\":\"string\"\n        \"title\": \"The Code\"\n      }\n    }\n  }\n\n  $scope.form = [\n    \"name\",\n    \"eligible\",\n    {\n      \"key\": \"code\",\n      \"condition\": \"person.eligible\", //or \"model.eligible\"\n    }\n  ]\n}  Note that angulars two-way binding automatically will update the conditional field, no need for\nevent handlers and such. The condition need not reference a model value it could be anything on\nscope.  The same example, but inside an array:  function FormCtrl($scope) {\n  $scope.persons = []\n\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"persons\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": {\n              \"type\": \"string\",\n              \"title\": \"Name\"\n            },\n            \"eligible\": {\n              \"type\": \"boolean\",\n              \"title\": \"Eligible for awesome things\"\n            },\n            \"code\": {\n              \"type\":\"string\"\n              \"title\": \"The Code\"\n            }\n          }\n        }\n      }\n    }\n  }\n\n  $scope.form = [\n    {\n      \"key\": \"persons\",\n      \"items\": [\n        \"persons[].name\",\n        \"persons[].eligible\",\n        {\n          key: \"persons[].code\",\n          condition: \"persons[arrayIndex].eligible\", //or \"model[arrayIndex].eligable\"\n        }\n      ]\n    }\n  ]\n}  Note that arrays inside arrays won\u2019t work with conditions.",
            "title": "condition"
        },
        {
            "location": "/#destroystrategy",
            "text": "By default, when a field is removed from the DOM and the  $destroy  event is broadcast, this happens\nif you use the  condition  option, the schema-validate directive will update the model to set the\nfield value to  undefined . This can be overridden by setting the destroyStrategy on a field, or as a\nglobal option, to one of the strings  \"null\" ,  \"empty\"  ,  \"remove\" , or  \"retain\" .  \"null\"  means that model values will be set to  null  instead of being removed.  \"empty\"  means empty strings,  \"\" , for model values that has the  string  type,  {}  for model\n  values with  object  type and  []  for  array  type. All other types will be treated as  \"remove\" .  \"remove\"  deletes the property. This is the default.  \"retain\"  keeps the value of the property event though the field is no longer in the form or being\nvaidated before submit.  If you\u2019d like to set the destroyStrategy for\nan entire form, add it to the  globalOptions",
            "title": "destroyStrategy"
        },
        {
            "location": "/#specific-options-and-types",
            "text": "",
            "title": "Specific options and types"
        },
        {
            "location": "/#input-group-addons",
            "text": "input  and  textarea  types can also have bootstrap input groups .  You can add them with the option  fieldAddonLeft  and  fieldAddonRight  which both takes a snippet\nof html.  [\n  {\n    \"key\": \"email\"\n    \"fieldAddonLeft\": \"@\"\n  }\n]",
            "title": "input group addons"
        },
        {
            "location": "/#fieldset-and-section",
            "text": "fieldset  and  section  doesn\u2019t need a key. You can create generic groups with them.\nThey do need a list of  items  to have as children.  {\n  type: \"fieldset\",\n  items: [\n    \"name\",\n    { key: \"surname\", notitle: true }\n  ]\n}",
            "title": "fieldset and section"
        },
        {
            "location": "/#select-and-checkboxes",
            "text": "select  and  checkboxes  can take an attribute,  titleMap , which defines a name\nand a value. The value is bound to the model while the name is used for display.\nIn the case of  checkboxes  the names of the titleMap can be HTML.  A  titleMap  can be specified as either an object (same as in JSON Form), where\nthe propery is the value and the value of that property is the name, or as\na list of name-value objects. The latter is used internally and is the recomended\nformat to use. Note that when defining a  titleMap  as an object the value is\nrestricted to strings since property names of objects always is a string.  As a list:  {\n  type: \"select\",\n  titleMap: [\n    { value: \"yes\", name: \"Yes I do\" },\n    { value: \"no\", name: \"Hell no\" }\n  ]\n}  As an object:  {\n  type: \"select\",\n  titleMap: {\n    \"yes\": \"Yes I do\",\n    \"no\": \"Hell no\"\n  }\n}  The  select  can also take an optional  group  property in its  titleMap  that adds  <optgroup> \nelement to the select.  {\n  type: \"select\",\n  titleMap: [\n    { value: \"yes\", name: \"Yes I do\", group: \"Boolean\" },\n    { value: \"no\", name: \"Hell no\" , group: \"Boolean\" },\n    { value: \"no\", name: \"File Not Found\", group: \"Other\" },\n  ]\n}",
            "title": "select and checkboxes"
        },
        {
            "location": "/#actions",
            "text": "actions  behaves the same as fieldset, but can only handle buttons and submits as children.  {\n  type: \"actions\",\n  items: [\n    { type: 'submit', title: 'Ok' }\n    { type: 'button', title: 'Cancel', onClick: \"cancel()\" }\n  ]\n}  The submit and other buttons have btn-default as default.\nWe can change this with  style  attribute:  {\n  type: \"actions\",\n  items: [\n    { type: 'submit', style: 'btn-success', title: 'Ok' }\n    { type: 'button', style: 'btn-info', title: 'Cancel', onClick: \"cancel()\" }\n  ]\n}",
            "title": "actions"
        },
        {
            "location": "/#button-and-submit",
            "text": "button  and  submit  can have a  onClick  attribute that either a function  or  a\nstring with an angular expression, as with ng-click. The expression is evaluated in the parent scope of\nthe  sf-schema  directive.  [\n  { type: 'submit', title: 'Ok', onClick: function(){ ...  } }\n  { type: 'button', title: 'Cancel', onClick: \"cancel()\" }\n[  The submit and other buttons have btn-default as default.\nWe can change this with  style  attribute:  [\n  { type: 'submit', style: 'btn-warning', title: 'Ok', onClick: function(){ ...  } }\n  { type: 'button', style: 'btn-danger', title: 'Cancel', onClick: \"cancel()\" }\n[  A  button  can also have optional icon classes:  [\n  {\n    type: 'button',\n    title: 'Cancel',\n    icon: 'glyphicon glyphicon-icon-exclamation-sign'\n    onClick: \"cancel()\"\n  }\n[",
            "title": "button and submit"
        },
        {
            "location": "/#radios-and-radiobuttons",
            "text": "Both type  radios  and  radiobuttons  work the same way.\nThey take a  titleMap  and renders ordinary radio buttons or bootstrap 3 buttons\ninline. It\u2019s a cosmetic choice.  The  titleMap  is either a list or an object, see  select and checkboxes \nfor details. The \u201cname\u201d part in the  titleMap  can be HTML.  Ex.  function FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      choice: {\n        type: \"string\",\n        enum: [\"one\",\"two\"]\n      }\n    }\n  };\n\n  $scope.form = [\n    {\n      key: \"choice\",\n      type: \"radiobuttons\",\n      titleMap: [\n        { value: \"one\", name: \"One\" },\n        { value, \"two\", name: \"More...\" }\n      ]\n    }\n  ];\n}  The actual schema property it binds doesn\u2019t need to be a string with an enum.\nHere is an example creating a yes no radio buttons that binds to a boolean.  Ex.  function FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      confirm: {\n        type: \"boolean\",\n        default: false\n      }\n    }\n  };\n\n  $scope.form = [\n    {\n      key: \"confirm\",\n      type: \"radios\",\n      titleMap: [\n        { value: false, name: \"No I don't understand these cryptic terms\" },\n        { value: true, , name: \"Yes this makes perfect sense to me\" }\n      ]\n    }\n  ];\n}  With  radiobuttons , both selected and unselected buttons have btn-default as default.\nWe can change this with  style  attribute:  function FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      choice: {\n        type: \"string\",\n        enum: [\"one\",\"two\"]\n      }\n    }\n  };\n\n  $scope.form = [\n    {\n      key: \"choice\",\n      type: \"radiobuttons\",\n      style: {\n        selected: \"btn-success\",\n        unselected: \"btn-default\"\n      },\n      titleMap: [\n     { value: \"one\", name: \"One\" },\n     { value, \"two\", name: \"More...\" }\n   ]\n  ];\n}",
            "title": "radios and radiobuttons"
        },
        {
            "location": "/#help",
            "text": "Help fields is not really a field, but instead let\u2019s you insert arbitrary HTML\ninto a form, suitable for help texts with links etc.  The get a help field you need to specify the type  help  and have a html\nsnippet as a string in the option  helpvalue  Ex.  function FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      name: {\n        title: \"Name\",\n        type: \"string\"\n      }\n    }\n  };\n\n  $scope.form = [\n    {\n      type: \"help\",\n      helpvalue: \"<h1>Yo Ninja!</h1>\"\n    },\n    \"name\"\n  ];\n}",
            "title": "help"
        },
        {
            "location": "/#template",
            "text": "template  fields are like  help  fields but instead of arbitrary html you can insert or refer to\nan angular template to be inserted where the field should go. There is one catch though and that\nis that the scope is that of the decorator directive and its inside the isolated scope of the sf-schema  directive, so anything you like to access in the template should be put on the form,\nwhich is available in template. It\u2019s basically a simple one shot version of add-ons, so see the\nsee the docs on  Extending Schema Form  for details on what is on scope and what\u2019s up\nwith  $$value$$  The  template  type should either have a  template  or a  templateUrl  option.  Ex.  function FormCtrl($scope) {\n\n  $scope.form = [\n    {\n      type: \"template\",\n      template: '<h1 ng-click=\"form.foo()\">Yo {{form.name}}!</h1>',\n      name: 'Ninja',\n      foo: function() { console.log('oh noes!'); }\n    },\n    {\n      type: \"template\",\n      templateUrl: \"templates/foo.html\",\n      myFavouriteVariable: 'OMG!!'\n    }\n  ];\n}",
            "title": "template"
        },
        {
            "location": "/#tabs",
            "text": "The  tabs  form type lets you split your form into tabs. It is similar to fieldset  in that it just changes the presentation of the form.  tabs \ntakes a option, also called  tabs , that is a list of tab objects. Each tab\nobject consist of a  title  and a  items  list of form objects.  Ex.  function FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      name: {\n        title: \"Name\",\n        type: \"string\"\n      },\n      nick: {\n        title: \"Nick\",\n        type: \"string\"\n      }\n      alias: {\n        title: \"Alias\",\n        type: \"string\"\n      }\n      tag: {\n        title: \"Tag\",\n        type: \"string\"\n      }\n    }\n  };\n\n  $scope.form = [\n    \"name\",\n    {\n      type: \"tabs\",\n      tabs: [\n        {\n          title: \"Tab 1\",\n          items: [\n            \"nick\",\n            \"alias\"\n          ]\n        },\n        {\n          title: \"Tab 2\",\n          items: [\n            \"tag\"\n          ]\n        }\n      ]\n    }\n  ];\n}",
            "title": "tabs"
        },
        {
            "location": "/#array",
            "text": "The  array  form type is the default for the schema type  array .\nThe schema for an array has the property  \"items\"  which in the JSON Schema\nspecification can be either another schema (i.e. and object), or a list of\nschemas. Only a schema is supported by Schema Form, and not the list of schemas.  The  form  definition has the option  items  that should be a list\nof form objects.  The rendered list of subforms each have a  \u201cRemove\u201d  button and at the bottom there\nis an  \u201cAdd\u201d  button. The default  \u201cAdd\u201d  button has class btn-default and text Add. Both\ncould be changed using attribute  add , see example below.  If you like to have drag and drop reordering of arrays you also need ui-sortable  and its dependencies jQueryUI , see  ui-sortable  documentation for details of\nwhat parts of jQueryUI that is needed. You can safely ignore these if you don\u2019t\nneed the reordering.  In the form definition you can refer to properties of an array item by the empty\nbracket notation. In the  key  simply end the name of the array with  []  By default the array will start with one  undefined  value so that the user is presented with one\nform element. To suppress this behaviour, set the attribute  startEmpty  to  true .  Given the schema:  {\n  \"type\": \"object\",\n  \"properties\": {\n    \"subforms\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": { \"type\": \"string\" },\n          \"nick\": { \"type\": \"string\" },\n          \"emails\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            }\n          }\n        }\n      }\n    }\n  }\n}  Then  subforms[].name  refers to the property name of any subform item, subforms[].emails[]  refers to the subform of emails. See example below for\nusage.  Single list of inputs example:  function FormCtrl($scope) {\n  $scope.schema = {\n    type: \"object\",\n    properties: {\n      names: {\n        type: \"array\",\n        items: {\n          title: \"Name\",\n          type: \"string\"\n        }\n      }\n    }\n  };\n\n  $scope.form = ['*'];\n}  Example with sub form, note that you can get rid of the form field the object wrapping the\nsubform fields gives you per default by using the  items  option in the\nform definition, also example of  startEmpty .  function FormCtrl($scope) {\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"subforms\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": { \"type\": \"string\" },\n            \"nick\": { \"type\": \"string\" },\n            \"emails\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n\n  $scope.form = [\n    {\n      key: \"subforms\",\n      add: \"Add person\",\n      style: {\n        add: \"btn-success\"\n      },\n      items: [\n        \"subforms[].nick\",\n        \"subforms[].name\",\n        \"subforms[].emails\",\n      ],\n      startEmpty: true\n    }\n  ];\n}  To suppress add and remove buttons set  add  to  null  and  remove  to  null .  function FormCtrl($scope) {\n  $scope.form = [\n    {\n      key: \"subforms\",\n      add: null,\n      remove: null,\n      style: {\n        add: \"btn-success\"\n      },\n      items: [\n        \"subforms[].nick\",\n        \"subforms[].name\",\n        \"subforms[].emails\",\n      ],\n    }\n  ];\n}",
            "title": "array"
        },
        {
            "location": "/#tabarray",
            "text": "The  tabarray  form type behaves the same way and has the same options as array  but instead of rendering a list it renders a tab per item in list.  By default the tabs are on the left side (follows the default in JSON Form),\nbut with the option  tabType  you can change that to eiter  \u201ctop\u201d  or  \u201cright\u201d \nas well.  Every tab page has a  \u201cRemove\u201d  button. The default  \u201cRemove\u201d  button has class btn-default\nand text Remove. Both could be changed using attribute  remove , see example below.  In this case we have an  \u201cAdd\u201d  link, not an  \u201cAdd\u201d  button. Therefore, the attribute  add \nonly changes the text of the link. See example below.  Bootstrap 3 doesn\u2019t have side tabs so to get proper styling you need to add the\ndependency  bootstrap-vertical-tabs .\nIt is not needed for tabs on top.  The  title  option is a bit special in  tabarray , it defines the title\nof the tab and it is interpolated so you can use expression it. Its interpolated\nwith two extra variables in context:  value  and  $index , where  value \nis the value in the array (i.e. that tab) and  $index  the index.  You can include multiple expressions or mix expressions and text as needed:\nEx:  \n    {\n      \"form\": [\n        {\n          \"type\": \"tabarray\",\n          \"title\": \"My {{ value.name }} is:\",\n        }\n      ]\n    }",
            "title": "tabarray"
        },
        {
            "location": "/#deprecation-warning",
            "text": "Before version 0.8.0 the entire title was evaluated as an expression and not interpolated.\nIf you weren\u2019t using expressions in your form titles then no changes are needed.  However, if your tabarray titles contain implicit Angular expressions like this:      {\n      \"form\": [\n        {\n          \"type\": \"tabarray\",\n          \"title\": \"value.name || 'Tab '+$index\",\n        }\n      ]\n    }  Then you should change this to explicit expressions by wrapping them with the Angular expression\ndelimiter \u201c{{ }}\u201d:      {\n      \"form\": [\n        {\n          \"type\": \"tabarray\",\n          \"title\": \"{{ value.name || 'Tab '+$index }}\",\n        }\n      ]\n    }  Example with tabs on the top:  function FormCtrl($scope) {\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"subforms\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": { \"type\": \"string\" },\n            \"nick\": { \"type\": \"string\" },\n            \"emails\": {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"string\"\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n\n  $scope.form = [\n    {\n      type: \"tabarray\",\n      tabType: \"top\",\n      title: \"{{value.nick || ('Tab '+$index)}}\"\n      key: \"subforms\",\n      remove: \"Delete\",\n      style: {\n        remove: \"btn-danger\"\n      },\n      add: \"Add person\",\n      items: [\n        \"subforms[].nick\",\n        \"subforms[].name\",\n        \"subforms[].emails\",\n      ]\n    }\n  ];\n}",
            "title": "Deprecation Warning"
        },
        {
            "location": "/#post-process-function",
            "text": "If you like to use  [\"*\"]  as a form, or aren\u2019t in control of the form definitions\nbut really need to change or add something you can register a  post process \nfunction with the  schemaForm  service provider. The post process function\ngets one argument, the final form merged with the defaults from the schema just\nbefore it\u2019s rendered, and should return a form.  Ex. Reverse all forms  angular.module('myModule', ['schemaForm']).config(function(schemaFormProvider){\n\n  schemaFormProvider.postProcess(function(form){\n    form.reverse();\n    return form;\n  })\n\n});",
            "title": "Post process function"
        },
        {
            "location": "/#events",
            "text": "Events are emitted or broadcast at various points in the process of rendering or validating the\nform. Below is a list of these events and how they are propagated.     Event  When  Type  Arguments      sf-render-finished  After form is rendered  emit  The sf-schema directives\u2019s element     Schema form also listens to events.     Event  What  Docs      schemaFormValidate  Validates all fields  Handling Submit    schemaFormRedraw  Redraws form  Updating Form",
            "title": "Events"
        },
        {
            "location": "/#manual-field-insertion",
            "text": "There is a limited feature for controlling manually where a generated field should go so you can\n,as an example, wrap it in custom html. Consider the feature experimental.  It has a number of drawbacks though.   You can only insert fields that are in the root level of your form definition, i.e. not inside fieldset, arrays etc.  Generated fields are always last in the form so if you don\u2019t supply slots for all of your top level fields the rest goes below.  To match \u201ckeys\u201d of forms we match against the internal array format, hence the key \u201cname\u201d becomes \u201c[\u2018name\u2019]\u201d and \u201cfoo.bar\u201d becomes \u201c[\u2018foo\u2019][\u2018bar\u2019]\u201d   Define \u201cslots\u201d for the generated field by adding an element with the attribute  sf-insert-field  ex.  $scope.form = [\n  \"name\",\n  \"email\",\n  \"comment\"\n]  <form sf-model=\"model\"\n      sf-form=\"form\"\n      sf-schema=\"schema\">\n  <em>before</em>\n  <div sf-insert-field=\"['email']\"></div>\n  <em>after</em>\n\n  <!-- the rest of the form, i.e. name and comment will be generated here -->\n</form>",
            "title": "Manual field insertion"
        },
        {
            "location": "/#deprecated-fields",
            "text": "",
            "title": "Deprecated fields"
        },
        {
            "location": "/#conditional",
            "text": "The  conditional  type is now deprecated since every form type now supports the form option condition .  A  conditional  is exactly the same as a  section , i.e. a  <div>  with other form elements in\nit, hence they need an  items  property. They also need a  condition  which is\na string with an angular expression. If that expression evaluates as thruthy the  conditional \nwill be rendered into the DOM otherwise not. The expression is evaluated in the parent scope of\nthe  sf-schema  directive (the same as onClick on buttons) but with access to the current model\nand current array index under the name  model  and  arrayIndex . This is useful for hiding/showing\nparts of a form depending on another form control.  ex. A checkbox that shows an input field for a code when checked  function FormCtrl($scope) {\n  $scope.person = {}\n\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"name\": {\n        \"type\": \"string\",\n        \"title\": \"Name\"\n      },\n      \"eligible\": {\n        \"type\": \"boolean\",\n        \"title\": \"Eligible for awesome things\"\n      },\n      \"code\": {\n        \"type\":\"string\"\n        \"title\": \"The Code\"\n      }\n    }\n  }\n\n  $scope.form = [\n    \"name\",\n    \"eligible\",\n    {\n        type: \"conditional\",\n        condition: \"model.person.eligible\",\n        items: [\n          \"code\"\n        ]\n    }\n  ]\n}  Note that angulars two-way binding automatically will update the conditional block, no need for\nevent handlers and such. The condition need not reference a model value it could be anything in\nscope.  The same example, but inside an array:  function FormCtrl($scope) {\n  $scope.persons = []\n\n  $scope.schema = {\n    \"type\": \"object\",\n    \"properties\": {\n      \"persons\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": {\n              \"type\": \"string\",\n              \"title\": \"Name\"\n            },\n            \"eligible\": {\n              \"type\": \"boolean\",\n              \"title\": \"Eligible for awesome things\"\n            },\n            \"code\": {\n              \"type\":\"string\"\n              \"title\": \"The Code\"\n            }\n          }\n        }\n      }\n    }\n  }\n\n  $scope.form = [\n    {\n      \"key\": \"persons\",\n      \"items\": [\n        \"persons[].name\",\n        \"persons[].eligible\",\n        {\n          type: \"conditional\",\n          condition: \"persons[arrayIndex].eligible\", //or \"model.eligable\"\n          items: [\n            \"persons[].code\"\n          ]\n        }\n      ]\n    }\n  ]\n}  Note that arrays inside arrays won\u2019t work with conditional.",
            "title": "conditional"
        },
        {
            "location": "/extending/",
            "text": "Extending Schema Form\n\u00b6\n\n\nSchema Form is designed to be easily extended and there are two basic ways to do it:\n\n\n\n\nAdd a new type of field\n\n\nAdd a new decorator\n\n\n\n\nAdding a Field\n\u00b6\n\n\nTo add a new field to Schema Form you need to create a new form type and match that form type with\na template snippet. To do this you use the \nschemaFormDecoratorsProvider.addMapping()\n function.\n\n\nEx. from the \ndatepicker add-on\n\n\n schemaFormDecoratorsProvider.addMapping(\n  'bootstrapDecorator',\n  'datepicker',\n  'directives/decorators/bootstrap/datepicker/datepicker.html'\n);\n\n\n\n\nThe second argument is the name of your new form type, in this case \ndatepicker\n, and the third is\nthe template we bind to it (the first is the decorator, use \nbootstrapDecorator\n unless you know\nwhat you are doing).\n\n\nWhat this means is that a form definition like this:\n\n\n$scope.form = [\n  {\n    key: \"birthday\",\n    type: \"datepicker\"\n  }\n];\n\n\n\n\n\u2026will result in the \ndatepicker.html\n template to be used to render that field in the form.\n\n\nBut wait, where is all the code? Basically it\u2019s then up to the template to use directives to\nimplement whatever it likes to do. It does have some help though, lets look at template example and\ngo through the basics.\n\n\nThis is sort of the template for the datepicker:\n\n\n<div class=\"form-group\" ng-class=\"{'has-error': hasError()}\">\n  <label class=\"control-label\" ng-show=\"showTitle()\">{{form.title}}</label>\n\n  <input ng-show=\"form.key\"\n         style=\"background-color: white\"\n         type=\"text\"\n         class=\"form-control\"\n         schema-validate=\"form\"\n         ng-model=\"$$value$$\"\n         pick-a-date\n         min-date=\"form.minDate\"\n         max-date=\"form.maxDate\"\n         format=\"form.format\" />\n\n  <span class=\"help-block\" sf-message=\"form.description\"></span>\n</div>\n\n\n\n\nWhat\u2019s on the scope?\n\u00b6\n\n\nEach form field will be rendered inside a decorator directive, created by the\n\nschemaFormDecorators\n factory service, \ndo\n\n\ncheck the source\n.\n\n\nThis means you have several helper functions and values on scope, most important of this \nform\n. The\n\nform\n variable contains the merged form definition for that field, i.e. your supplied form object +\nthe defaults from the schema (it also has its part of the schema under \nform.schema\n).\nThis is how you define and use new form field options, whatever is set on the form object is\navailable here for you to act on.\n\n\n\n\n\n\n\n\nName\n\n\nWhat it does\n\n\n\n\n\n\n\n\n\n\nform\n\n\nForm definition object\n\n\n\n\n\n\nshowTitle()\n\n\nShorthand for \nform && form.notitle !== true && form.title\n\n\n\n\n\n\nngModel\n\n\nThe ngModel controller, this will be on scope if you use either the directive \nschema-validate\n or \nsf-array\n\n\n\n\n\n\nevalInScope(expr, locals)\n\n\nEval supplied expression, ie scope.$eval\n\n\n\n\n\n\nevalExpr(expr, locals)\n\n\nEval an expression in the parent scope of the main \nsf-schema\n directive.\n\n\n\n\n\n\ninterp(expr, locals)\n\n\nInterpolate an expression which may or may not contain expression \n{{ }}\n sequences\n\n\n\n\n\n\nbuttonClick($event, form)\n\n\nUse this with ng-click to execute form.onClick\n\n\n\n\n\n\nhasSuccess()\n\n\nShorthand for \nngModel.$valid && (!ngModel.$pristine || !ngModel.$isEmpty(ngModel.$modelValue))\n\n\n\n\n\n\nhasError()\n\n\nShorthand for \nngModel.$invalid && !ngModel.$pristine\n\n\n\n\n\n\n\n\nDeprecation warning\n\u00b6\n\n\nThere is still a \nerrorMessage\n function on scope but it\u2019s been deprecated. Please use the\n\nsf-message\n directive instead.\n\n\nThe magic $$value$$\n\u00b6\n\n\nSchema Form wants to play nice with the built in Angular directives for form. Especially \nng-model\n\nwhich we want to handle the two way binding against our model value. Also by using \nng-model\n we\nget all the nice validation states from the \nngModelController\n and \nFormController\n that we all\nknow and love.\n\n\nTo get that working properly we had to resort to a bit of trickery, right before we let Angular\ncompile the field template we do a simple string replacement of \n$$value$$\n and replace that\nwith the path to the current form field on the model, i.e. \nform.key\n.\n\n\nSo \nng-model=\"$$value$$\"\n becomes something like \nng-model=\"model['person']['address']['street']\"\n,\nyou can see this if you inspect the final form in the browser.\n\n\nSo basically always have a \nng-model=\"$$value$$\"\n (Pro tip: ng-model is fine on any element, put\n  it on the same div as your custom directive and require the ngModelController for full control).\n\n\nschema-validate directive\n\u00b6\n\n\nschema-validate\n is a directive that you should put on the same element as your \nng-model\n. It is\nresponsible for validating the value against the schema using \ntv4js\n\nIt takes the form definition as an argument.\n\n\nsf-message directive\n\u00b6\n\n\nError messages are nice, and the best way to get them is via the \nsf-message\n directive. It usually\ntakes \nform.description\n as an argument so it can show that until an error occurs.\n\n\nSetting up schema defaults\n\u00b6\n\n\nSo you got this shiny new add-on that adds a fancy field type, but feel a bit bummed out that you\nneed to specify it in the form definition all the time? Fear not because you can also add a \u201crule\u201d\nto map certain types and conditions in the schema to default to your type.\n\n\nYou do this by adding to the \nschemaFormProvider.defaults\n object. The \nschemaFormProvider.defaults\n\nis an object with a key for each type \nin JSON Schema\n with a array of functions as its value.\n\n\nvar defaults = {\n  string: [],\n  object: [],\n  number: [],\n  integer: [],\n  boolean: [],\n  array: []\n};\n\n\n\n\nWhen schema form traverses the JSON Schema to create default form definitions it first checks the\n\nJSON Schema type\n and then calls on each function in the corresponding list \nin order\n until a\nfunction actually returns something. That is then used as a defualt.\n\n\nThis is the function that makes it a datepicker if its a string and has format \u201cdate\u201d or \u201cdate-time\u201d:\n\n\nvar datepicker = function(name, schema, options) {\n  if (schema.type === 'string' && (schema.format === 'date' || schema.format === 'date-time')) {\n    var f = schemaFormProvider.stdFormObj(name, schema, options);\n    f.key = options.path;\n    f.type = 'datepicker';\n    options.lookup[sfPathProvider.stringify(options.path)] = f;\n    return f;\n  }\n};\n\n// Put it first in the list of functions\nschemaFormProvider.defaults.string.unshift(datepicker);\n\n\n\n\nSharing your add-on with the world\n\u00b6\n\n\nSo you made an add-on, why not share it with us? On the front page,\n\nhttp://textalk.github.io/angular-schema-form/\n, we\nmaintain a list of add ons based on a query of the bower register, and we love to see your add-on\nthere.\n\n\nAny \nbower\n package with a name starting with \nangular-schema-form-\n or that has\nthe \nkeyword\n \nangular-schema-form-add-on\n in its \nbower.json\n will be picked up. It\u2019s cached so\nthere can be a delay of a day or so.\n\n\nSo \nmake a bower package\n, add the keyword\n\nangular-schema-form-add-on\n and \nregister it\n!\n\n\nDecorators\n\u00b6\n\n\nDecorators are a second way to extend Schema Form, the thought being that you should easily be able\nto change \nevery\n field. Maybe you like it old school and want to use bootstrap 2. Or maybe you like\nto generate a table with the data instead? Right now there are no other decorators than bootstrap 3.\n\n\nBasically a \ndecorator\n sets up all the mappings between form types and their respective templates\nusing the \nschemaFormDecoratorsProvider.createDecorator()\n function.\n\n\nvar base = 'directives/decorators/bootstrap/';\n\nschemaFormDecoratorsProvider.createDecorator('bootstrapDecorator', {\n  textarea: base + 'textarea.html',\n  fieldset: base + 'fieldset.html',\n  array: base + 'array.html',\n  tabarray: base + 'tabarray.html',\n  tabs: base + 'tabs.html',\n  section: base + 'section.html',\n  conditional: base + 'section.html',\n  actions: base + 'actions.html',\n  select: base + 'select.html',\n  checkbox: base + 'checkbox.html',\n  checkboxes: base + 'checkboxes.html',\n  number: base + 'default.html',\n  password: base + 'default.html',\n  submit: base + 'submit.html',\n  button: base + 'submit.html',\n  radios: base + 'radios.html',\n  'radios-inline': base + 'radios-inline.html',\n  radiobuttons: base + 'radio-buttons.html',\n  help: base + 'help.html',\n  'default': base + 'default.html'\n}, [\n  function(form) {\n    if (form.readonly && form.key && form.type !== 'fieldset') {\n      return base + 'readonly.html';\n    }\n  }\n]);\n\n\n\n\nschemaFormDecoratorsProvider.createDecorator(name, mapping, rules)\n takes a name argument, a mapping object\n(type -> template) and an optional list of rule functions.\n\n\nWhen the decorator is trying to match a form type against a tempate it first executes all the rules\nin order. If one returns that is used as template, otherwise it checks the mappings.",
            "title": "Extending"
        },
        {
            "location": "/extending/#extending-schema-form",
            "text": "Schema Form is designed to be easily extended and there are two basic ways to do it:   Add a new type of field  Add a new decorator",
            "title": "Extending Schema Form"
        },
        {
            "location": "/extending/#adding-a-field",
            "text": "To add a new field to Schema Form you need to create a new form type and match that form type with\na template snippet. To do this you use the  schemaFormDecoratorsProvider.addMapping()  function.  Ex. from the  datepicker add-on   schemaFormDecoratorsProvider.addMapping(\n  'bootstrapDecorator',\n  'datepicker',\n  'directives/decorators/bootstrap/datepicker/datepicker.html'\n);  The second argument is the name of your new form type, in this case  datepicker , and the third is\nthe template we bind to it (the first is the decorator, use  bootstrapDecorator  unless you know\nwhat you are doing).  What this means is that a form definition like this:  $scope.form = [\n  {\n    key: \"birthday\",\n    type: \"datepicker\"\n  }\n];  \u2026will result in the  datepicker.html  template to be used to render that field in the form.  But wait, where is all the code? Basically it\u2019s then up to the template to use directives to\nimplement whatever it likes to do. It does have some help though, lets look at template example and\ngo through the basics.  This is sort of the template for the datepicker:  <div class=\"form-group\" ng-class=\"{'has-error': hasError()}\">\n  <label class=\"control-label\" ng-show=\"showTitle()\">{{form.title}}</label>\n\n  <input ng-show=\"form.key\"\n         style=\"background-color: white\"\n         type=\"text\"\n         class=\"form-control\"\n         schema-validate=\"form\"\n         ng-model=\"$$value$$\"\n         pick-a-date\n         min-date=\"form.minDate\"\n         max-date=\"form.maxDate\"\n         format=\"form.format\" />\n\n  <span class=\"help-block\" sf-message=\"form.description\"></span>\n</div>",
            "title": "Adding a Field"
        },
        {
            "location": "/extending/#whats-on-the-scope",
            "text": "Each form field will be rendered inside a decorator directive, created by the schemaFormDecorators  factory service,  do  check the source .  This means you have several helper functions and values on scope, most important of this  form . The form  variable contains the merged form definition for that field, i.e. your supplied form object +\nthe defaults from the schema (it also has its part of the schema under  form.schema ).\nThis is how you define and use new form field options, whatever is set on the form object is\navailable here for you to act on.     Name  What it does      form  Form definition object    showTitle()  Shorthand for  form && form.notitle !== true && form.title    ngModel  The ngModel controller, this will be on scope if you use either the directive  schema-validate  or  sf-array    evalInScope(expr, locals)  Eval supplied expression, ie scope.$eval    evalExpr(expr, locals)  Eval an expression in the parent scope of the main  sf-schema  directive.    interp(expr, locals)  Interpolate an expression which may or may not contain expression  {{ }}  sequences    buttonClick($event, form)  Use this with ng-click to execute form.onClick    hasSuccess()  Shorthand for  ngModel.$valid && (!ngModel.$pristine || !ngModel.$isEmpty(ngModel.$modelValue))    hasError()  Shorthand for  ngModel.$invalid && !ngModel.$pristine",
            "title": "What's on the scope?"
        },
        {
            "location": "/extending/#deprecation-warning",
            "text": "There is still a  errorMessage  function on scope but it\u2019s been deprecated. Please use the sf-message  directive instead.",
            "title": "Deprecation warning"
        },
        {
            "location": "/extending/#the-magic-value",
            "text": "Schema Form wants to play nice with the built in Angular directives for form. Especially  ng-model \nwhich we want to handle the two way binding against our model value. Also by using  ng-model  we\nget all the nice validation states from the  ngModelController  and  FormController  that we all\nknow and love.  To get that working properly we had to resort to a bit of trickery, right before we let Angular\ncompile the field template we do a simple string replacement of  $$value$$  and replace that\nwith the path to the current form field on the model, i.e.  form.key .  So  ng-model=\"$$value$$\"  becomes something like  ng-model=\"model['person']['address']['street']\" ,\nyou can see this if you inspect the final form in the browser.  So basically always have a  ng-model=\"$$value$$\"  (Pro tip: ng-model is fine on any element, put\n  it on the same div as your custom directive and require the ngModelController for full control).",
            "title": "The magic $$value$$"
        },
        {
            "location": "/extending/#schema-validate-directive",
            "text": "schema-validate  is a directive that you should put on the same element as your  ng-model . It is\nresponsible for validating the value against the schema using  tv4js \nIt takes the form definition as an argument.",
            "title": "schema-validate directive"
        },
        {
            "location": "/extending/#sf-message-directive",
            "text": "Error messages are nice, and the best way to get them is via the  sf-message  directive. It usually\ntakes  form.description  as an argument so it can show that until an error occurs.",
            "title": "sf-message directive"
        },
        {
            "location": "/extending/#setting-up-schema-defaults",
            "text": "So you got this shiny new add-on that adds a fancy field type, but feel a bit bummed out that you\nneed to specify it in the form definition all the time? Fear not because you can also add a \u201crule\u201d\nto map certain types and conditions in the schema to default to your type.  You do this by adding to the  schemaFormProvider.defaults  object. The  schemaFormProvider.defaults \nis an object with a key for each type  in JSON Schema  with a array of functions as its value.  var defaults = {\n  string: [],\n  object: [],\n  number: [],\n  integer: [],\n  boolean: [],\n  array: []\n};  When schema form traverses the JSON Schema to create default form definitions it first checks the JSON Schema type  and then calls on each function in the corresponding list  in order  until a\nfunction actually returns something. That is then used as a defualt.  This is the function that makes it a datepicker if its a string and has format \u201cdate\u201d or \u201cdate-time\u201d:  var datepicker = function(name, schema, options) {\n  if (schema.type === 'string' && (schema.format === 'date' || schema.format === 'date-time')) {\n    var f = schemaFormProvider.stdFormObj(name, schema, options);\n    f.key = options.path;\n    f.type = 'datepicker';\n    options.lookup[sfPathProvider.stringify(options.path)] = f;\n    return f;\n  }\n};\n\n// Put it first in the list of functions\nschemaFormProvider.defaults.string.unshift(datepicker);",
            "title": "Setting up schema defaults"
        },
        {
            "location": "/extending/#sharing-your-add-on-with-the-world",
            "text": "So you made an add-on, why not share it with us? On the front page, http://textalk.github.io/angular-schema-form/ , we\nmaintain a list of add ons based on a query of the bower register, and we love to see your add-on\nthere.  Any  bower  package with a name starting with  angular-schema-form-  or that has\nthe  keyword   angular-schema-form-add-on  in its  bower.json  will be picked up. It\u2019s cached so\nthere can be a delay of a day or so.  So  make a bower package , add the keyword angular-schema-form-add-on  and  register it !",
            "title": "Sharing your add-on with the world"
        },
        {
            "location": "/extending/#decorators",
            "text": "Decorators are a second way to extend Schema Form, the thought being that you should easily be able\nto change  every  field. Maybe you like it old school and want to use bootstrap 2. Or maybe you like\nto generate a table with the data instead? Right now there are no other decorators than bootstrap 3.  Basically a  decorator  sets up all the mappings between form types and their respective templates\nusing the  schemaFormDecoratorsProvider.createDecorator()  function.  var base = 'directives/decorators/bootstrap/';\n\nschemaFormDecoratorsProvider.createDecorator('bootstrapDecorator', {\n  textarea: base + 'textarea.html',\n  fieldset: base + 'fieldset.html',\n  array: base + 'array.html',\n  tabarray: base + 'tabarray.html',\n  tabs: base + 'tabs.html',\n  section: base + 'section.html',\n  conditional: base + 'section.html',\n  actions: base + 'actions.html',\n  select: base + 'select.html',\n  checkbox: base + 'checkbox.html',\n  checkboxes: base + 'checkboxes.html',\n  number: base + 'default.html',\n  password: base + 'default.html',\n  submit: base + 'submit.html',\n  button: base + 'submit.html',\n  radios: base + 'radios.html',\n  'radios-inline': base + 'radios-inline.html',\n  radiobuttons: base + 'radio-buttons.html',\n  help: base + 'help.html',\n  'default': base + 'default.html'\n}, [\n  function(form) {\n    if (form.readonly && form.key && form.type !== 'fieldset') {\n      return base + 'readonly.html';\n    }\n  }\n]);  schemaFormDecoratorsProvider.createDecorator(name, mapping, rules)  takes a name argument, a mapping object\n(type -> template) and an optional list of rule functions.  When the decorator is trying to match a form type against a tempate it first executes all the rules\nin order. If one returns that is used as template, otherwise it checks the mappings.",
            "title": "Decorators"
        },
        {
            "location": "/knownlimitations/",
            "text": "Known Limitations\n\u00b6\n\n\nAngular Version\n\u00b6\n\n\nSchema Form works with AngularJS version 1.2.x or above, but version 1.3.x is recommended.\n\n\nThis is because a bug in AngularJS 1.2 \n#8039\n,\nwhich means that the \nng-model\n directive has problem with values that uses a bracket notation instead of dot notation.\n\n\n<!-- dot notation -->\n<input ng-model=\"foo.bar.baz\">\n\n<!-- bracket notation -->\n<input ng-model=\"foo['bar']['baz']\">\n\n\n\n\nSo what does that mean for you as a user of Schema Form? Basically it boils down to that if you use AngularJS 1.2.x\nSchema Form uses dot notation, which means your property names in the JSON schema \nmust not contain any hyphens or other\ncharacters dot notation cannot handle\n.\n\n\nExample schema that only works in 1.3\n\n\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"key-with-hyphen\": { \"type\": \"string\" },\n  }\n}\n\n\n\n\nThe \u201ccomplex keys\u201d example schema illustrates this as well.\nFor more background check out issue \n#41\n and the PR that fixed\nit, \nPR 43\n. Thanks to @mike-marcacci for his excellent work!",
            "title": "Limitations"
        },
        {
            "location": "/knownlimitations/#known-limitations",
            "text": "",
            "title": "Known Limitations"
        },
        {
            "location": "/knownlimitations/#angular-version",
            "text": "Schema Form works with AngularJS version 1.2.x or above, but version 1.3.x is recommended.  This is because a bug in AngularJS 1.2  #8039 ,\nwhich means that the  ng-model  directive has problem with values that uses a bracket notation instead of dot notation.  <!-- dot notation -->\n<input ng-model=\"foo.bar.baz\">\n\n<!-- bracket notation -->\n<input ng-model=\"foo['bar']['baz']\">  So what does that mean for you as a user of Schema Form? Basically it boils down to that if you use AngularJS 1.2.x\nSchema Form uses dot notation, which means your property names in the JSON schema  must not contain any hyphens or other\ncharacters dot notation cannot handle .  Example schema that only works in 1.3  {\n  \"type\": \"object\",\n  \"properties\": {\n    \"key-with-hyphen\": { \"type\": \"string\" },\n  }\n}  The \u201ccomplex keys\u201d example schema illustrates this as well.\nFor more background check out issue  #41  and the PR that fixed\nit,  PR 43 . Thanks to @mike-marcacci for his excellent work!",
            "title": "Angular Version"
        }
    ]
}